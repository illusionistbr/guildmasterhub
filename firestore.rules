
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isGuildOwner(guildData, userId) {
      return guildData.ownerId == userId;
    }

    function isGuildLeader(guildData, userId) {
      return guildData.roles[userId] is map && guildData.roles[userId].generalRole == 'Líder';
    }

    function isGuildLeaderOrViceLeader(guildData, userId) {
      return guildData.roles[userId] is map && 
             (guildData.roles[userId].generalRole == 'Líder' || guildData.roles[userId].generalRole == 'Vice-Líder');
    }
    
    function isGuildMember(guildData, userId) {
      return userId in guildData.memberIds;
    }

    function getGuildData(guildId) {
      return get(/databases/$(database)/documents/guilds/$(guildId)).data;
    }

    // User Profiles
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == userId &&
                      request.resource.data.uid == userId &&
                      request.resource.data.displayName is string &&
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.createdAt == request.time &&
                      (!('photoURL' in request.resource.data) || request.resource.data.photoURL is string || request.resource.data.photoURL == null) &&
                      (!('guilds' in request.resource.data) || request.resource.data.guilds is list) &&
                      (!('lastNotificationsCheckedTimestamp' in request.resource.data) || request.resource.data.lastNotificationsCheckedTimestamp is map);
      allow update: if isAuthenticated() && request.auth.uid == userId &&
                      // Allow updating displayName, photoURL, and lastNotificationsCheckedTimestamp
                      request.resource.data.uid == resource.data.uid &&
                      request.resource.data.email == resource.data.email &&
                      request.resource.data.createdAt == resource.data.createdAt &&
                      (!('displayName' in request.resource.data) || request.resource.data.displayName is string) &&
                      (!('photoURL' in request.resource.data) || request.resource.data.photoURL is string || request.resource.data.photoURL == null) &&
                      (!('lastNotificationsCheckedTimestamp' in request.resource.data) || request.resource.data.lastNotificationsCheckedTimestamp is map);
                      // Guilds array should ideally be managed by guild join/leave logic, not direct user update.
      allow delete: if false; // Generally, users don't delete their own auth-linked profiles directly
    }

    // Guilds
    match /guilds/{guildId} {
      allow read: if isAuthenticated(); // Any authenticated user can read basic guild list for discovery
      
      allow create: if isAuthenticated() &&
                      request.auth.uid == request.resource.data.ownerId &&
                      request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50 &&
                      request.resource.data.game is string && request.resource.data.game.size() > 0 &&
                      request.resource.data.memberCount == 1 &&
                      request.auth.uid in request.resource.data.memberIds &&
                      request.resource.data.memberIds.size() == 1 &&
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.isOpen is bool &&
                      (!('description' in request.resource.data) || request.resource.data.description is string) &&
                      (!('password' in request.resource.data) || request.resource.data.password is string) &&
                      (!('bannerUrl' in request.resource.data) || request.resource.data.bannerUrl is string) &&
                      (!('logoUrl' in request.resource.data) || request.resource.data.logoUrl is string) &&
                      request.resource.data.roles[request.auth.uid] is map &&
                      request.resource.data.roles[request.auth.uid].generalRole == 'Líder' &&
                      request.resource.data.roles[request.auth.uid].dkpBalance == 0 &&
                      (!('socialLinks' in request.resource.data) || request.resource.data.socialLinks is map);

      allow update: if isAuthenticated() && (
                      // Owner can update settings like name, description, password, visibility, game, banner, logo, socialLinks
                      (isGuildOwner(resource.data, request.auth.uid) &&
                        (!('name' in request.resource.data) || (request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50)) &&
                        (!('description'in request.resource.data) || request.resource.data.description is string) &&
                        (!('password' in request.resource.data) || request.resource.data.password is string || request.resource.data.password == null) &&
                        (!('isOpen' in request.resource.data) || request.resource.data.isOpen is bool) &&
                        (!('game' in request.resource.data) || request.resource.data.game is string) &&
                        (!('bannerUrl' in request.resource.data) || request.resource.data.bannerUrl is string) &&
                        (!('logoUrl' in request.resource.data) || request.resource.data.logoUrl is string) &&
                        (!('socialLinks' in request.resource.data) || request.resource.data.socialLinks is map) &&
                        // Ensure other critical fields are not changed by owner directly here
                        request.resource.data.ownerId == resource.data.ownerId &&
                        request.resource.data.createdAt == resource.data.createdAt
                      ) ||
                      // Leader or ViceLeader can manage member roles and status (more granular checks for role changes ideally in Cloud Functions)
                      (isGuildLeaderOrViceLeader(resource.data, request.auth.uid) &&
                        request.resource.data.diff(resource.data).affectedKeys().hasAny(['roles', 'memberIds', 'memberCount']) // Restrict to these fields for role/member management
                        // Add specific checks for what fields within roles can be changed if needed
                      ) ||
                      // Member can update their own DKP balance (via increment) - client must ensure it's an increment
                      (isGuildMember(resource.data, request.auth.uid) &&
                        request.resource.data.keys().hasOnly(resource.data.keys().concat(['roles'])) && 
                        request.resource.data.roles.keys().hasOnly(resource.data.roles.keys().concat([request.auth.uid])) &&
                        request.resource.data.roles[request.auth.uid].keys().hasOnly(resource.data.roles[request.auth.uid].keys().concat(['dkpBalance'])) &&
                        request.resource.data.roles[request.auth.uid].dkpBalance is number &&
                        (resource.data.roles[request.auth.uid] == null || request.resource.data.roles[request.auth.uid].dkpBalance >= resource.data.roles[request.auth.uid].dkpBalance || resource.data.roles[request.auth.uid].dkpBalance == 0)
                      ) ||
                      // Public guild join or application acceptance (memberIds, memberCount, roles can change)
                      (
                        (request.resource.data.memberCount == resource.data.memberCount + 1 &&
                         request.resource.data.memberIds == resource.data.memberIds.concat([request.auth.uid])) || // Simplified for public join
                        (isGuildLeaderOrViceLeader(resource.data, request.auth.uid) && // for accepting applications
                         request.resource.data.memberCount == resource.data.memberCount + 1)
                      )
                    );
      
      allow delete: if isAuthenticated() && isGuildOwner(resource.data, request.auth.uid);

      // Guild Events
      match /events/{eventId} {
        allow read: if isAuthenticated() && isGuildMember(getGuildData(guildId), request.auth.uid);
        allow create: if isAuthenticated() && isGuildLeaderOrViceLeader(getGuildData(guildId), request.auth.uid) &&
                        request.resource.data.guildId == guildId &&
                        request.resource.data.organizerId == request.auth.uid &&
                        request.resource.data.title is string && request.resource.data.title.size() > 0 &&
                        request.resource.data.date is string && // Ideally validate date format
                        request.resource.data.time is string && // Ideally validate time format
                        request.resource.data.createdAt == request.time &&
                        (!('description' in request.resource.data) || request.resource.data.description is string) &&
                        (!('endDate' in request.resource.data) || request.resource.data.endDate is string) &&
                        (!('endTime' in request.resource.data) || request.resource.data.endTime is string) &&
                        (!('location' in request.resource.data) || request.resource.data.location is string) &&
                        (!('dkpValue' in request.resource.data) || request.resource.data.dkpValue is number) &&
                        (!('requiresPin' in request.resource.data) || request.resource.data.requiresPin is bool) &&
                        (!('pinCode' in request.resource.data) || request.resource.data.pinCode is string && request.resource.data.pinCode.size() == 6) &&
                        (!('attendeesWithPin' in request.resource.data) || request.resource.data.attendeesWithPin is list);

        allow update: if isAuthenticated() && (
                        // Organizer or Leader/ViceLeader can update
                        (request.auth.uid == resource.data.organizerId || isGuildLeaderOrViceLeader(getGuildData(guildId), request.auth.uid)) ||
                        // Authenticated guild member can add themselves to attendeesWithPin
                        (isGuildMember(getGuildData(guildId), request.auth.uid) &&
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendeesWithPin']) &&
                         !(request.auth.uid in resource.data.attendeesWithPin) && // Not already attended
                         request.resource.data.attendeesWithPin == resource.data.attendeesWithPin.concat([request.auth.uid]) // Only adding self
                        )
                      ) &&
                      request.resource.data.guildId == guildId && // Ensure guildId cannot be changed
                      request.resource.data.organizerId == resource.data.organizerId && // Ensure organizer cannot be changed by non-owner of event
                      request.resource.data.createdAt == resource.data.createdAt; // Ensure createdAt is not changed
                      // Add other field validations similar to create if needed

        allow delete: if isAuthenticated() && (request.auth.uid == resource.data.organizerId || isGuildLeaderOrViceLeader(getGuildData(guildId), request.auth.uid));
      }

      // Guild Applications
      match /applications/{applicationId} {
        allow read: if isAuthenticated() && isGuildLeaderOrViceLeader(getGuildData(guildId), request.auth.uid);
        // Users can create their own application
        allow create: if isAuthenticated() && request.auth.uid == request.resource.data.applicantId &&
                        request.resource.data.guildId == guildId &&
                        request.resource.data.applicantName is string && request.resource.data.applicantName.size() > 0 &&
                        request.resource.data.gearScore is number &&
                        request.resource.data.gearScoreScreenshotUrl is string && // Ideally validate URL
                        request.resource.data.discordNick is string && request.resource.data.discordNick.size() > 0 &&
                        request.resource.data.status == 'pending' &&
                        request.resource.data.submittedAt == request.time &&
                        // TL specific fields are optional or validated if present
                        (!(request.resource.data.keys().hasAny(['tlRole', 'tlPrimaryWeapon', 'tlSecondaryWeapon'])) || 
                          ( (request.resource.data.tlRole is string) && 
                            (request.resource.data.tlPrimaryWeapon is string) &&
                            (request.resource.data.tlSecondaryWeapon is string)
                          )
                        );
        // Leader/ViceLeader can update status (approve/reject)
        allow update: if isAuthenticated() && isGuildLeaderOrViceLeader(getGuildData(guildId), request.auth.uid) &&
                        request.resource.data.guildId == guildId &&
                        request.resource.data.applicantId == resource.data.applicantId &&
                        request.resource.data.submittedAt == resource.data.submittedAt &&
                        request.resource.data.status in ['approved', 'rejected', 'auto_approved'] && // auto_approved for public form entries
                        request.resource.data.reviewedBy == request.auth.uid &&
                        request.resource.data.reviewedAt == request.time;
        allow delete: if isAuthenticated() && isGuildLeaderOrViceLeader(getGuildData(guildId), request.auth.uid);
      }

      // Audit Logs
      match /auditLogs/{logId} {
        allow read: if isAuthenticated() && isGuildLeaderOrViceLeader(getGuildData(guildId), request.auth.uid);
        allow create: if isAuthenticated() && isGuildMember(getGuildData(guildId), request.auth.uid) && // Any member can trigger actions that are logged
                        request.resource.data.guildId == guildId && // This is not in the data, log is subcollection
                        request.resource.data.actorId == request.auth.uid &&
                        request.resource.data.timestamp == request.time &&
                        request.resource.data.action is string &&
                        request.resource.data.details is map;
        allow update, delete: if false; // Logs should be immutable
      }
      
      // Notifications
      match /notifications/{notificationId} {
        allow read: if isAuthenticated() && isGuildMember(getGuildData(guildId), request.auth.uid); // All members can read notifications for their guild
        allow create: if isAuthenticated() && isGuildLeaderOrViceLeader(getGuildData(guildId), request.auth.uid) && // Only leaders/vice can create certain notifications
                        request.resource.data.guildId == guildId &&
                        request.resource.data.message is string &&
                        request.resource.data.type is string && // Add specific enum validation if needed
                        request.resource.data.link is string &&
                        request.resource.data.timestamp == request.time;
        allow update: if isAuthenticated() && isGuildMember(getGuildData(guildId), request.auth.uid) &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']) && // Only allow updating 'isRead' status
                        request.resource.data.isRead is bool;
        allow delete: if isAuthenticated() && isGuildLeaderOrViceLeader(getGuildData(guildId), request.auth.uid); // Only leaders/vice can delete
      }
    }
  }
}


rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(guildDocData) {
      return isAuthenticated() && request.auth.uid == guildDocData.ownerId;
    }

    function isGuildMember(guildDocData) {
      // Ensure memberIds exists and is a list before calling hasAny
      return isAuthenticated() &&
             guildDocData.memberIds != null &&
             typeof guildDocData.memberIds.hasAny == 'function' && // Check if it's a list-like object for rules
             guildDocData.memberIds.hasAny([request.auth.uid]);
    }

    // permissionName must be a string literal like 'MANAGE_MEMBERS_KICK'
    function hasGuildPermission(guildDocData, permissionName) {
      return isAuthenticated() &&
             guildDocData.roles != null &&
             request.auth.uid in guildDocData.roles &&
             guildDocData.roles[request.auth.uid].roleName != null && // Ensure roleName is not null
             guildDocData.customRoles != null &&
             guildDocData.roles[request.auth.uid].roleName in guildDocData.customRoles &&
             guildDocData.customRoles[guildDocData.roles[request.auth.uid].roleName].permissions != null &&
             typeof guildDocData.customRoles[guildDocData.roles[request.auth.uid].roleName].permissions.hasAny == 'function' &&
             guildDocData.customRoles[guildDocData.roles[request.auth.uid].roleName].permissions.hasAny([permissionName]);
    }

    // User profiles
    match /users/{userId} {
      allow read: if isAuthenticated() && request.auth.uid == userId;
      allow create: if isAuthenticated() && request.auth.uid == userId &&
                       request.resource.data.uid == userId &&
                       request.resource.data.createdAt == request.time &&
                       !("guilds" in request.resource.data); // guilds should be empty on creation
      allow update: if isAuthenticated() && request.auth.uid == userId &&
                       // Allow updating displayName, photoURL, lastNotificationsCheckedTimestamp
                       request.resource.data.keys().hasOnly(['displayName', 'photoURL', 'lastNotificationsCheckedTimestamp', 'uid', 'email', 'createdAt']) &&
                       request.resource.data.uid == resource.data.uid &&
                       request.resource.data.email == resource.data.email &&
                       request.resource.data.createdAt == resource.data.createdAt;
    }

    // Guilds
    match /guilds/{guildId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.memberIds.hasAll([request.auth.uid]) &&
                       request.resource.data.memberCount == 1 &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.name.size() > 0;

      allow update: if isAuthenticated() && (
        // 1. Owner can update most top-level fields
        (isOwner(resource.data) &&
          request.resource.data.ownerId == resource.data.ownerId && // Cannot change owner
          request.resource.data.createdAt == resource.data.createdAt && // Cannot change createdAt
          // memberCount and memberIds are managed by specific join/kick/accept logic, not direct owner update here for safety
          request.resource.data.memberCount == resource.data.memberCount &&
          request.resource.data.memberIds.toSet() == resource.data.memberIds.toSet() &&
          // Check that only allowed fields are part of the update diff or roles/customRoles (which have their own detailed rules below if not owner)
          (
            request.resource.data.diff(resource.data).affectedKeys().hasOnly([
              'name', 'description', 'bannerUrl', 'logoUrl', 'game', 'region', 'server', 'tags',
              'password', 'isOpen', 'socialLinks',
              'dkpSystemEnabled', 'dkpRedemptionWindow', 'dkpDefaultsPerCategory',
              'dkpDecayEnabled', 'dkpDecayPercentage', 'dkpDecayIntervalDays', 'dkpDecayInitialDate',
              'lastDkpDecayTimestamp', 'roles', 'customRoles', 'recruitmentQuestions'
              // Exclude memberIds, memberCount, ownerId, createdAt from this general owner update condition as they are sensitive
            ])
          )
        ) ||
        // 2. Member updating their own character info (specific fields within roles[uid])
        (isGuildMember(resource.data) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']) &&
          request.resource.data.roles.diff(resource.data.roles).affectedKeys().hasOnly([request.auth.uid]) &&
          request.resource.data.roles[request.auth.uid].diff(resource.data.roles[request.auth.uid]).affectedKeys()
            .hasOnly(['characterNickname', 'gearScore', 'gearScoreScreenshotUrl', 'gearBuildLink', 'skillBuildLink', 'tlRole', 'tlPrimaryWeapon', 'tlSecondaryWeapon', 'notes', 'status']) &&
          request.resource.data.roles[request.auth.uid].roleName == resource.data.roles[request.auth.uid].roleName &&
          request.resource.data.roles[request.auth.uid].dkpBalance == resource.data.roles[request.auth.uid].dkpBalance
        ) ||
        // 3. Updating customRoles by someone with MANAGE_ROLES_PERMISSIONS
        (hasGuildPermission(resource.data, 'MANAGE_ROLES_PERMISSIONS') &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['customRoles']) &&
          request.resource.data.ownerId == resource.data.ownerId && // Non-owners cannot change other guild settings
          request.resource.data.memberCount == resource.data.memberCount &&
          request.resource.data.memberIds.toSet() == resource.data.memberIds.toSet()
        ) ||
        // 4. Updating specific fields in roles map by users with MANAGE_MEMBERS_EDIT_ROLE, MANAGE_MEMBERS_EDIT_STATUS, or MANAGE_MEMBERS_EDIT_NOTES
        ( (hasGuildPermission(resource.data, 'MANAGE_MEMBERS_EDIT_ROLE') || hasGuildPermission(resource.data, 'MANAGE_MEMBERS_EDIT_STATUS') || hasGuildPermission(resource.data, 'MANAGE_MEMBERS_EDIT_NOTES') ) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']) &&
          request.resource.data.roles.diff(resource.data.roles).affectedKeys().size() > 0 &&
          request.resource.data.roles.diff(resource.data.roles).affectedKeys().map(
            uid =>
              (uid != request.auth.uid || isOwner(resource.data)) && // Cannot edit self unless owner
              (request.resource.data.roles[uid].diff(resource.data.roles[uid]).affectedKeys().hasOnly(['roleName', 'status', 'notes'])) &&
              (uid != resource.data.ownerId || isOwner(resource.data)) && // Cannot edit owner unless owner
              request.resource.data.roles[uid].dkpBalance == resource.data.roles[uid].dkpBalance // Cannot change DKP with these permissions
          ).hasAll([true]) &&
          request.resource.data.ownerId == resource.data.ownerId &&
          request.resource.data.memberCount == resource.data.memberCount &&
          request.resource.data.memberIds.toSet() == resource.data.memberIds.toSet()
        ) ||
        // 5. Kicking a member (updates memberIds, memberCount, roles.{kickedUid})
        ((isOwner(resource.data) || hasGuildPermission(resource.data, 'MANAGE_MEMBERS_KICK')) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberIds', 'memberCount', 'roles']) &&
          request.resource.data.memberCount == resource.data.memberCount - 1 &&
          request.resource.data.roles.keys().size() == resource.data.roles.keys().size() - 1 &&
          !request.resource.data.memberIds.hasAll(resource.data.memberIds) && // Ensures a member was actually removed
          request.resource.data.ownerId == resource.data.ownerId // Prevent changing ownerId during kick
        ) ||
        // 6. Accepting an application (updates memberIds, memberCount, roles.{newMemberUid})
        (((isOwner(resource.data) || hasGuildPermission(resource.data, 'MANAGE_RECRUITMENT_PROCESS_APPLICATIONS'))) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberIds', 'memberCount', 'roles']) &&
          request.resource.data.memberCount == resource.data.memberCount + 1 &&
          request.resource.data.roles.keys().size() == resource.data.roles.keys().size() + 1 &&
          !resource.data.memberIds.hasAll(request.resource.data.memberIds) && // Ensures a member was actually added
          request.resource.data.ownerId == resource.data.ownerId // Prevent changing ownerId during accept
        ) ||
        // 7. DKP awarded via PIN or On-Demand Decay (owner updates roles for on-demand, member updates self for PIN)
        (
          (isGuildMember(resource.data) && // For PIN redemption
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']) &&
            request.resource.data.roles.diff(resource.data.roles).affectedKeys().hasOnly([request.auth.uid]) &&
            request.resource.data.roles[request.auth.uid].diff(resource.data.roles[request.auth.uid]).affectedKeys().hasOnly(['dkpBalance']) &&
            request.resource.data.roles[request.auth.uid].dkpBalance >= resource.data.roles[request.auth.uid].dkpBalance // DKP can only increase or stay same
          ) ||
          (isOwner(resource.data) && // For On-Demand Decay by Owner
            request.resource.data.dkpDecayEnabled == true &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']) &&
            request.resource.data.roles.diff(resource.data.roles).affectedKeys().map( // Check all affected roles
              uid => request.resource.data.roles[uid].diff(resource.data.roles[uid]).affectedKeys().hasOnly(['dkpBalance'])
            ).hasAll([true])
          )
        ) &&
        request.resource.data.ownerId == resource.data.ownerId // General safety: ownerId cannot change during these DKP ops
      );

      allow delete: if isAuthenticated() && isOwner(resource.data);

      // Subcollections
      match /auditLogs/{logId} {
        allow read: if isAuthenticated() && hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'VIEW_AUDIT_LOG');
        allow create: if isAuthenticated() && isGuildMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                         request.resource.data.actorId == request.auth.uid &&
                         request.resource.data.timestamp == request.time;
        allow update, delete: if false;
      }

      match /applications/{applicationId} {
        allow read: if isAuthenticated() && (
                       hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_RECRUITMENT_VIEW_APPLICATIONS') ||
                       request.auth.uid == resource.data.applicantId
                     );
        allow create: if isAuthenticated() &&
                         request.resource.data.applicantId == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.status == 'pending' &&
                         request.resource.data.submittedAt == request.time;
        allow update: if isAuthenticated() && hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_RECRUITMENT_PROCESS_APPLICATIONS') &&
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'reviewedBy', 'reviewedAt']) &&
                         request.resource.data.reviewedAt == request.time &&
                         request.resource.data.reviewedBy == request.auth.uid &&
                         request.resource.data.applicantId == resource.data.applicantId &&
                         request.resource.data.guildId == resource.data.guildId &&
                         request.resource.data.submittedAt == resource.data.submittedAt;
        allow delete: if false;
      }

      match /events/{eventId} {
        allow read: if isAuthenticated() && isGuildMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
        allow create: if isAuthenticated() && hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_EVENTS_CREATE') &&
                         request.resource.data.organizerId == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.createdAt == request.time;
        allow update: if isAuthenticated() && (
                        (request.auth.uid == resource.data.organizerId && request.resource.data.organizerId == resource.data.organizerId) ||
                        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_EVENTS_EDIT')
                       ) &&
                       request.resource.data.guildId == resource.data.guildId &&
                       request.resource.data.createdAt == resource.data.createdAt &&
                       (
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendeesWithPin']) || // Member redeeming PIN
                         request.resource.data.diff(resource.data).affectedKeys().hasAny([ // Organizer/Admin editing event
                           'title', 'description', 'date', 'time', 'endDate', 'endTime', 'location',
                           'dkpValue', 'requiresPin', 'pinCode', 'attendeesWithPin', 'category', 'subCategory'
                         ])
                       );
        allow delete: if isAuthenticated() && (
                         request.auth.uid == resource.data.organizerId ||
                         hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_EVENTS_DELETE')
                       );
      }

      match /groups/{groupId} {
        allow read: if isAuthenticated() && isGuildMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
        allow create: if isAuthenticated() && hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_GROUPS_CREATE') &&
                         request.resource.data.createdBy == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.createdAt == request.time;
        allow update: if isAuthenticated() && hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_GROUPS_EDIT') &&
                         request.resource.data.createdBy == resource.data.createdBy &&
                         request.resource.data.guildId == resource.data.guildId &&
                         request.resource.data.createdAt == resource.data.createdAt;
        allow delete: if isAuthenticated() && hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_GROUPS_DELETE');
      }

      match /notifications/{notificationId} {
        allow read: if isAuthenticated() && isGuildMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
        allow create: if isAuthenticated() && isGuildMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                         request.resource.data.createdByUserId == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.timestamp == request.time;
        allow update, delete: if false;
      }

      match /dkpDecayLogs/{logId} {
          allow read: if isAuthenticated() && isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data);
          allow create: if isAuthenticated() && isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                           request.resource.data.timestamp == request.time;
          allow update, delete: if false;
      }
    }
  }
}

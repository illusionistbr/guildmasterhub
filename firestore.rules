rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions (simplified to return a single boolean expression)
    function isUserAuthenticated() {
      return request.auth != null && request.auth.uid != null;
    }

    function getGuildData(guildId) {
      return get(/databases/$(database)/documents/guilds/$(guildId)).data;
    }

    function getUserRoleInGuild(guildId, userId) {
      let guildData = getGuildData(guildId);
      // Ensure roles map and specific user role entry exist before accessing generalRole
      return guildData.roles != null && userId in guildData.roles && guildData.roles[userId].generalRole != null ? guildData.roles[userId].generalRole : null;
    }

    function isGuildOwner(guildId, userId) {
      return getGuildData(guildId).ownerId == userId;
    }

    function isGuildLeader(guildId, userId) {
      return getUserRoleInGuild(guildId, userId) == "Lider";
    }

    function isGuildViceLeader(guildId, userId) {
      return getUserRoleInGuild(guildId, userId) == "ViceLider";
    }

    function isGuildMember(guildId, userId) {
      // Check if user is listed in memberIds and also has a role defined
      let guildData = getGuildData(guildId);
      return guildData.memberIds != null && userId in guildData.memberIds && guildData.roles != null && userId in guildData.roles;
    }

    // Users Collection
    match /users/{userId} {
      allow read: if isUserAuthenticated();
      allow create: if isUserAuthenticated() && request.auth.uid == userId
                    && request.resource.data.uid == userId
                    && request.resource.data.email == request.auth.token.email
                    && request.resource.data.displayName is string
                    && (request.resource.data.photoURL == null || request.resource.data.photoURL is string)
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.guilds is list && request.resource.data.guilds.size() == 0
                    && request.resource.data.lastNotificationsCheckedTimestamp is map && request.resource.data.lastNotificationsCheckedTimestamp.size() == 0;
      allow update: if isUserAuthenticated() && request.auth.uid == userId
                    // Allow updating displayName, photoURL, guilds, and lastNotificationsCheckedTimestamp
                    && (request.resource.data.displayName == resource.data.displayName || request.resource.data.displayName is string)
                    && (request.resource.data.photoURL == resource.data.photoURL || request.resource.data.photoURL is string || request.resource.data.photoURL == null)
                    && (request.resource.data.guilds == resource.data.guilds || request.resource.data.guilds is list)
                    && (request.resource.data.lastNotificationsCheckedTimestamp == resource.data.lastNotificationsCheckedTimestamp || request.resource.data.lastNotificationsCheckedTimestamp is map)
                    // Prevent modification of other fields
                    && request.resource.data.uid == resource.data.uid
                    && request.resource.data.email == resource.data.email
                    && request.resource.data.createdAt == resource.data.createdAt;
      allow delete: if false; // Generally users should not delete their own accounts directly via rules
    }

    // Guilds Collection
    match /guilds/{guildId} {
      allow read: if isUserAuthenticated(); // Any authenticated user can read guild list for exploration

      allow create: if isUserAuthenticated()
                    && request.resource.data.ownerId == request.auth.uid
                    && request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50
                    && (request.resource.data.description == null || (request.resource.data.description is string && request.resource.data.description.size() <= 500))
                    && request.resource.data.game is string && request.resource.data.game.size() >= 1 && request.resource.data.game.size() <= 50
                    && (request.resource.data.password == null || (request.resource.data.password is string && request.resource.data.password.size() <= 50))
                    && (request.resource.data.socialLinks == null || (
                        request.resource.data.socialLinks is map
                        && (request.resource.data.socialLinks.facebook == null || request.resource.data.socialLinks.facebook is string && request.resource.data.socialLinks.facebook.size() <= 200)
                        && (request.resource.data.socialLinks.x == null || request.resource.data.socialLinks.x is string && request.resource.data.socialLinks.x.size() <= 200)
                        && (request.resource.data.socialLinks.youtube == null || request.resource.data.socialLinks.youtube is string && request.resource.data.socialLinks.youtube.size() <= 200)
                        && (request.resource.data.socialLinks.discord == null || request.resource.data.socialLinks.discord is string && request.resource.data.socialLinks.discord.size() <= 200)
                    ))
                    && request.resource.data.ownerDisplayName is string
                    && request.resource.data.memberIds is list && request.resource.data.memberIds.size() == 1 && request.auth.uid in request.resource.data.memberIds
                    && request.resource.data.memberCount == 1
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.isOpen == (request.resource.data.password == null)
                    && request.resource.data.bannerUrl is string
                    && request.resource.data.logoUrl is string
                    && request.resource.data.roles is map && request.resource.data.roles.size() == 1 && request.auth.uid in request.resource.data.roles
                    && request.resource.data.roles[request.auth.uid].generalRole == "Lider" // Must use ASCII "Lider"
                    && (request.resource.data.roles[request.auth.uid].dkpBalance == null || request.resource.data.roles[request.auth.uid].dkpBalance is number);


      allow update: if isUserAuthenticated()
                    // Owner can update most settings
                    && ((isGuildOwner(guildId, request.auth.uid)
                          && (request.resource.data.name == resource.data.name || (request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50))
                          && (request.resource.data.description == resource.data.description || request.resource.data.description is string && request.resource.data.description.size() <= 500)
                          && (request.resource.data.game == resource.data.game || request.resource.data.game is string && request.resource.data.game.size() >= 1 && request.resource.data.game.size() <= 50)
                          && (request.resource.data.password == resource.data.password || (request.resource.data.password is string && request.resource.data.password.size() <= 50) || request.resource.data.password == null)
                          && (request.resource.data.socialLinks == resource.data.socialLinks || request.resource.data.socialLinks is map) // Simplified social links check
                          && (request.resource.data.bannerUrl == resource.data.bannerUrl || request.resource.data.bannerUrl is string)
                          && (request.resource.data.logoUrl == resource.data.logoUrl || request.resource.data.logoUrl is string)
                          && request.resource.data.isOpen == (request.resource.data.password == null)
                        )
                        // Leader or ViceLeader can manage roles and member lists
                        || ((isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid))
                            && (request.resource.data.roles == resource.data.roles || request.resource.data.roles is map) // Allow roles map to be different
                            && (request.resource.data.memberIds == resource.data.memberIds || request.resource.data.memberIds is list)
                            && (request.resource.data.memberCount == resource.data.memberCount || request.resource.data.memberCount is number)
                           )
                        // A user joining a public guild
                        || (
                            resource.data.isOpen == true &&
                            request.auth.uid in request.resource.data.memberIds && !(request.auth.uid in resource.data.memberIds) && // User is being added
                            request.resource.data.memberIds.size() == resource.data.memberIds.size() + 1 &&
                            request.resource.data.memberCount == resource.data.memberCount + 1 &&
                            request.resource.data.roles[request.auth.uid].generalRole == "Membro" && // Role being added is Member
                            (request.resource.data.roles[request.auth.uid].dkpBalance == null || request.resource.data.roles[request.auth.uid].dkpBalance is number && request.resource.data.roles[request.auth.uid].dkpBalance >= 0) &&
                            (request.resource.data.roles[request.auth.uid].notes is string || request.resource.data.roles[request.auth.uid].notes == null) &&
                            (request.resource.data.roles[request.auth.uid].status is string || request.resource.data.roles[request.auth.uid].status == null) &&
                            // Check TL fields if they exist
                            (request.resource.data.roles[request.auth.uid].tlRole == null || request.resource.data.roles[request.auth.uid].tlRole is string) &&
                            (request.resource.data.roles[request.auth.uid].tlPrimaryWeapon == null || request.resource.data.roles[request.auth.uid].tlPrimaryWeapon is string) &&
                            (request.resource.data.roles[request.auth.uid].tlSecondaryWeapon == null || request.resource.data.roles[request.auth.uid].tlSecondaryWeapon is string)
                        )
                       )
                    // Ensure non-updatable fields remain the same across all update scenarios
                    && request.resource.data.ownerId == resource.data.ownerId
                    && request.resource.data.ownerDisplayName == resource.data.ownerDisplayName
                    && request.resource.data.createdAt == resource.data.createdAt;

      allow delete: if isUserAuthenticated() && isGuildOwner(guildId, request.auth.uid);

      // --- Subcollections of Guilds ---

      // Applications Subcollection
      match /applications/{applicationId} {
        allow read: if isUserAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid));
        allow create: if isUserAuthenticated()
                        && request.resource.data.guildId == guildId
                        && request.resource.data.applicantId == request.auth.uid
                        && request.resource.data.applicantName is string && request.resource.data.applicantName.size() > 0
                        && request.resource.data.applicantDisplayName is string
                        && (request.resource.data.applicantPhotoURL == null || request.resource.data.applicantPhotoURL is string)
                        && request.resource.data.gearScore is number && request.resource.data.gearScore >= 0
                        && request.resource.data.gearScoreScreenshotUrl is string && request.resource.data.gearScoreScreenshotUrl.matches('https?://.+')
                        && request.resource.data.discordNick is string && request.resource.data.discordNick.size() > 0
                        && request.resource.data.submittedAt == request.time
                        && ( // Logic for status based on guild type
                            (getGuildData(guildId).isOpen == true && request.resource.data.status == "auto_approved" && request.resource.data.reviewedBy == "system") ||
                            (getGuildData(guildId).isOpen == false && request.resource.data.status == "pending")
                           )
                        // Optional TL fields validation
                        && (request.resource.data.tlRole == null || request.resource.data.tlRole is string)
                        && (request.resource.data.tlPrimaryWeapon == null || request.resource.data.tlPrimaryWeapon is string)
                        && (request.resource.data.tlSecondaryWeapon == null || request.resource.data.tlSecondaryWeapon is string);

        allow update: if isUserAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid))
                        && request.resource.data.guildId == resource.data.guildId
                        && request.resource.data.applicantId == resource.data.applicantId
                        && (request.resource.data.status == "approved" || request.resource.data.status == "rejected")
                        && request.resource.data.reviewedBy == request.auth.uid
                        && request.resource.data.reviewedAt == request.time
                        // Ensure other fields are not changed during review
                        && request.resource.data.applicantName == resource.data.applicantName
                        && request.resource.data.applicantDisplayName == resource.data.applicantDisplayName
                        && request.resource.data.applicantPhotoURL == resource.data.applicantPhotoURL
                        && request.resource.data.gearScore == resource.data.gearScore
                        && request.resource.data.gearScoreScreenshotUrl == resource.data.gearScoreScreenshotUrl
                        && request.resource.data.discordNick == resource.data.discordNick
                        && request.resource.data.submittedAt == resource.data.submittedAt
                        && request.resource.data.tlRole == resource.data.tlRole
                        && request.resource.data.tlPrimaryWeapon == resource.data.tlPrimaryWeapon
                        && request.resource.data.tlSecondaryWeapon == resource.data.tlSecondaryWeapon;
        allow delete: if false; // Applications are generally not deleted, but marked
      }

      // AuditLogs Subcollection
      match /auditLogs/{logId} {
        allow read: if isUserAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid));
        allow create: if isUserAuthenticated() // System/Server or authorized user creates logs
                        && request.resource.data.actorId == request.auth.uid // Logged in user is the actor
                        && request.resource.data.timestamp == request.time
                        && request.resource.data.actorDisplayName is string
                        && request.resource.data.action is string
                        && request.resource.data.details is map;
        allow update, delete: if false; // Logs should be immutable
      }

      // Events Subcollection
      match /events/{eventId} {
        allow read: if isUserAuthenticated() && isGuildMember(guildId, request.auth.uid); // Any guild member can read events
        allow create: if isUserAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid))
                        && request.resource.data.guildId == guildId
                        && request.resource.data.title is string && request.resource.data.title.size() > 0
                        && request.resource.data.date is string // YYYY-MM-DD
                        && request.resource.data.time is string // HH:MM
                        && request.resource.data.organizerId == request.auth.uid
                        && request.resource.data.createdAt == request.time
                        && (request.resource.data.description == null || request.resource.data.description is string)
                        && (request.resource.data.endDate == null || request.resource.data.endDate is string)
                        && (request.resource.data.endTime == null || request.resource.data.endTime is string)
                        && (request.resource.data.location == null || request.resource.data.location is string)
                        && (request.resource.data.dkpValue == null || (request.resource.data.dkpValue is number && request.resource.data.dkpValue >= 0))
                        && request.resource.data.requiresPin is bool
                        && (request.resource.data.pinCode == null || (request.resource.data.requiresPin == true && request.resource.data.pinCode is string && request.resource.data.pinCode.size() == 6))
                        && (request.resource.data.attendeesWithPin == null || request.resource.data.attendeesWithPin is list)
                        && (request.resource.data.category == null || request.resource.data.category is string)
                        && (request.resource.data.subCategory == null || request.resource.data.subCategory is string);

        allow update: if isUserAuthenticated()
                        // Event organizer, Leader, or ViceLeader can update
                        && (resource.data.organizerId == request.auth.uid || isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid))
                        // Only allow updating specific fields, others must remain same
                        && request.resource.data.guildId == resource.data.guildId
                        && request.resource.data.organizerId == resource.data.organizerId // Organizer cannot change
                        && request.resource.data.createdAt == resource.data.createdAt     // CreatedAt cannot change
                        // Updatable fields
                        && (request.resource.data.title is string && request.resource.data.title.size() > 0)
                        && (request.resource.data.date is string)
                        && (request.resource.data.time is string)
                        && (request.resource.data.description == null || request.resource.data.description is string)
                        && (request.resource.data.endDate == null || request.resource.data.endDate is string)
                        && (request.resource.data.endTime == null || request.resource.data.endTime is string)
                        && (request.resource.data.location == null || request.resource.data.location is string)
                        && (request.resource.data.dkpValue == null || (request.resource.data.dkpValue is number && request.resource.data.dkpValue >= 0))
                        && (request.resource.data.requiresPin is bool)
                        && (request.resource.data.pinCode == resource.data.pinCode || (request.resource.data.requiresPin == true && request.resource.data.pinCode is string && request.resource.data.pinCode.size() == 6) || (request.resource.data.requiresPin == false && request.resource.data.pinCode == null) )
                        && (request.resource.data.category == null || request.resource.data.category is string)
                        && (request.resource.data.subCategory == null || request.resource.data.subCategory is string)
                        // AttendeesWithPin list can be updated by members submitting a correct PIN
                        || (isUserAuthenticated() && request.auth.uid in request.resource.data.attendeesWithPin && !(request.auth.uid in resource.data.attendeesWithPin)
                            && request.resource.data.attendeesWithPin.size() == resource.data.attendeesWithPin.size() + 1
                            // All other fields must remain the same when only attendeesWithPin is updated
                            && request.resource.data.title == resource.data.title
                            && request.resource.data.date == resource.data.date
                            // ... (check all other non-attendeesWithPin fields)
                           );


        allow delete: if isUserAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid) || resource.data.organizerId == request.auth.uid);
      }

      // Groups Subcollection
      match /groups/{groupId} {
        allow read: if isUserAuthenticated() && isGuildMember(guildId, request.auth.uid);
        allow create: if isUserAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid))
                        && request.resource.data.guildId == guildId
                        && request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50
                        && request.resource.data.icon is string && (request.resource.data.icon == "shield" || request.resource.data.icon == "sword" || request.resource.data.icon == "heart")
                        && request.resource.data.headerColor is string // Basic check, specific color values not validated here for simplicity
                        && request.resource.data.members is list && request.resource.data.members.size() >= 1 && request.resource.data.members.size() <= 6
                        && request.resource.data.members[0].memberId is string // Basic check for first member, loop in rules is complex
                        && request.resource.data.createdAt == request.time
                        && request.resource.data.createdBy == request.auth.uid;
        allow update: if isUserAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid))
                        && request.resource.data.guildId == resource.data.guildId
                        && request.resource.data.createdBy == resource.data.createdBy // Cannot change creator
                        && request.resource.data.createdAt == resource.data.createdAt // Cannot change creation time
                        // Validate updatable fields
                        && request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50
                        && request.resource.data.icon is string && (request.resource.data.icon == "shield" || request.resource.data.icon == "sword" || request.resource.data.icon == "heart")
                        && request.resource.data.headerColor is string
                        && request.resource.data.members is list && request.resource.data.members.size() >= 1 && request.resource.data.members.size() <= 6;

        allow delete: if isUserAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid));
      }

      // Notifications Subcollection
      match /notifications/{notificationId} {
        allow read: if isUserAuthenticated() && isGuildMember(guildId, request.auth.uid); // Any guild member can read notifications for their guild
        allow create: if isUserAuthenticated() // System or authorized user (Leader/ViceLeader for manual, system for auto)
                        && request.resource.data.guildId == guildId
                        && request.resource.data.message is string && request.resource.data.message.size() > 0
                        && request.resource.data.type is string // Add more specific type checks if needed
                        && request.resource.data.link is string
                        && request.resource.data.timestamp == request.time
                        && (request.resource.data.createdByUserId == request.auth.uid || request.resource.data.createdByUserId == "system") // Example
                        && (request.resource.data.createdByUserDisplayname is string || request.resource.data.createdByUserDisplayname == null);
        allow update: if false; // Notifications are generally immutable
        allow delete: if false; // Or only by specific admin roles if cleanup is needed
      }
    }
  }
}

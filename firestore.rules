
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUserProfileOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Guild related helper functions
    function getGuild(guildId) {
      return get(/databases/$(database)/documents/guilds/$(guildId));
    }

    function getGuildData(guildId) {
      return getGuild(guildId).data;
    }

    function isGuildOwner(guildId, userId) {
      let guildData = getGuildData(guildId);
      return guildData.ownerId == userId;
    }

    function getUserGuildRole(guildId, userId) {
      let guildData = getGuildData(guildId);
      // Check if roles exist and the user's role entry exists and is a map
      return guildData.roles != null &&
             guildData.roles[userId] != null &&
             guildData.roles[userId] is map ?
             guildData.roles[userId].generalRole : null;
    }

    function isGuildLeader(guildId, userId) {
      return getUserGuildRole(guildId, userId) == 'Líder';
    }

    function isGuildViceLeader(guildId, userId) {
      return getUserGuildRole(guildId, userId) == 'Vice-Líder';
    }

    function isGuildLeaderOrViceLeader(guildId, userId) {
      let role = getUserGuildRole(guildId, userId);
      return role == 'Líder' || role == 'Vice-Líder';
    }

    function isGuildMember(guildId, userId) {
      let guildData = getGuildData(guildId);
      return guildData.memberIds is list && userId in guildData.memberIds;
    }

    // User Profiles
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isUserProfileOwner(userId) &&
                       request.resource.data.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       request.resource.data.displayName is string && request.resource.data.displayName.size() > 0 &&
                       (!('photoURL' in request.resource.data) || request.resource.data.photoURL is string || request.resource.data.photoURL == null) &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.guilds is list && request.resource.data.guilds.size() == 0 &&
                       request.resource.data.lastNotificationsCheckedTimestamp is map && request.resource.data.lastNotificationsCheckedTimestamp.size() == 0 &&
                       request.resource.data.keys().hasOnly(['uid', 'email', 'displayName', 'photoURL', 'createdAt', 'guilds', 'lastNotificationsCheckedTimestamp']);
      allow update: if isUserProfileOwner(userId) &&
                       request.resource.data.uid == userId && // uid cannot change
                       request.resource.data.email == resource.data.email && // email cannot change via this update
                       request.resource.data.displayName is string && request.resource.data.displayName.size() > 0 &&
                       (!('photoURL' in request.resource.data) || request.resource.data.photoURL is string || request.resource.data.photoURL == null) &&
                       request.resource.data.createdAt == resource.data.createdAt && // createdAt cannot change
                       request.resource.data.guilds is list && // Guilds list can be updated by other means (joining/leaving guild)
                       request.resource.data.lastNotificationsCheckedTimestamp is map && // This can be updated
                       request.resource.data.keys().hasOnly(['uid', 'email', 'displayName', 'photoURL', 'createdAt', 'guilds', 'lastNotificationsCheckedTimestamp']);
      // No delete for user profiles through client by default
    }

    // Guilds
    match /guilds/{guildId} {
      allow read: if isAuthenticated(); // Any authenticated user can read guild list for exploration
      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50 &&
                       request.resource.data.memberCount == 1 &&
                       request.resource.data.memberIds is list && request.resource.data.memberIds.size() == 1 && request.resource.data.memberIds[0] == request.auth.uid &&
                       request.resource.data.roles is map && request.resource.data.roles[request.auth.uid] is map && request.resource.data.roles[request.auth.uid].generalRole == 'Líder' &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.game is string &&
                       (!('description' in request.resource.data) || request.resource.data.description is string && request.resource.data.description.size() <= 500) &&
                       (!('password' in request.resource.data) || request.resource.data.password is string && request.resource.data.password.size() <= 50 || request.resource.data.password == null) &&
                       request.resource.data.isOpen == (!('password' in request.resource.data) || request.resource.data.password == null) &&
                       (!('bannerUrl' in request.resource.data) || request.resource.data.bannerUrl is string && request.resource.data.bannerUrl.matches('https://.*')) &&
                       (!('logoUrl' in request.resource.data) || request.resource.data.logoUrl is string && request.resource.data.logoUrl.matches('https://.*')) &&
                       (!('socialLinks' in request.resource.data) || request.resource.data.socialLinks is map) &&
                       (!('tags' in request.resource.data) || request.resource.data.tags is list) &&
                       request.resource.data.ownerDisplayName == request.auth.token.name &&
                       request.resource.data.keys().hasOnly([
                         'name', 'description', 'memberCount', 'bannerUrl', 'logoUrl', 'ownerId', 'ownerDisplayName',
                         'memberIds', 'game', 'tags', 'createdAt', 'password', 'isOpen', 'socialLinks', 'roles'
                       ]);

      allow update: if isAuthenticated() && isGuildOwner(guildId, request.auth.uid) && // Only owner can update general settings
                       request.resource.data.ownerId == resource.data.ownerId && // Owner cannot be changed here
                       request.resource.data.createdAt == resource.data.createdAt && // CreatedAt cannot change
                       request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50 &&
                       (!('description' in request.resource.data) || request.resource.data.description is string && request.resource.data.description.size() <= 500) &&
                       (!('password' in request.resource.data) || request.resource.data.password is string && request.resource.data.password.size() <= 50 || request.resource.data.password == null) &&
                       request.resource.data.isOpen == (!('password' in request.resource.data) || request.resource.data.password == null) &&
                       (!('bannerUrl' in request.resource.data) || request.resource.data.bannerUrl is string && request.resource.data.bannerUrl.matches('https://.*')) &&
                       (!('logoUrl' in request.resource.data) || request.resource.data.logoUrl is string && request.resource.data.logoUrl.matches('https://.*')) &&
                       // Member management (count, ids, roles) should be handled by specific actions or cloud functions for complex logic
                       request.resource.data.memberCount == resource.data.memberCount || (isGuildLeaderOrViceLeader(guildId, request.auth.uid) || isGuildOwner(guildId, request.auth.uid)) &&
                       request.resource.data.memberIds == resource.data.memberIds || (isGuildLeaderOrViceLeader(guildId, request.auth.uid) || isGuildOwner(guildId, request.auth.uid)) &&
                       request.resource.data.roles == resource.data.roles || (isGuildLeaderOrViceLeader(guildId, request.auth.uid) || isGuildOwner(guildId, request.auth.uid)) &&
                       request.resource.data.keys().hasOnly([
                         'name', 'description', 'memberCount', 'bannerUrl', 'logoUrl', 'ownerId', 'ownerDisplayName',
                         'memberIds', 'game', 'tags', 'createdAt', 'password', 'isOpen', 'socialLinks', 'roles'
                       ]);
                       // More granular updates for roles, memberIds, memberCount:
                       // Allow Leaders/ViceLeaders to modify roles, memberIds, memberCount
                       // Allow members to update their own specific role details (like TLWeapon if structure allows)
                       // This is complex for client-side rules, often better with Cloud Functions.
                       // Example for updating own role by member (simplified):
                       // (userId == request.auth.uid && request.resource.data.roles[userId] is map && /* validations for specific role fields */)

      allow delete: if isAuthenticated() && isGuildOwner(guildId, request.auth.uid); // Only owner can delete guild

      // Events subcollection
      match /events/{eventId} {
        allow read: if isAuthenticated() && isGuildMember(guildId, request.auth.uid); // Members can read events
        allow create: if isAuthenticated() && isGuildLeaderOrViceLeader(guildId, request.auth.uid) &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.organizerId == request.auth.uid &&
                         request.resource.data.title is string && request.resource.data.title.size() > 0 &&
                         request.resource.data.date is string && // Should be ISO date string
                         request.resource.data.time is string && // Should be HH:MM format
                         (!('description' in request.resource.data) || request.resource.data.description is string) &&
                         (!('endDate' in request.resource.data) || request.resource.data.endDate is string) &&
                         (!('endTime' in request.resource.data) || request.resource.data.endTime is string) &&
                         (!('location' in request.resource.data) || request.resource.data.location is string) &&
                         (!('dkpValue' in request.resource.data) || request.resource.data.dkpValue is number && request.resource.data.dkpValue >= 0) &&
                         (!('requiresPin' in request.resource.data) || request.resource.data.requiresPin is bool) &&
                         (!('pinCode' in request.resource.data) || (request.resource.data.requiresPin == true && request.resource.data.pinCode is string && request.resource.data.pinCode.size() == 6)) &&
                         request.resource.data.createdAt == request.time &&
                         request.resource.data.keys().hasOnly([
                            'guildId', 'title', 'description', 'date', 'time', 'endDate', 'endTime', 'location', 'organizerId',
                            'dkpValue', 'requiresPin', 'pinCode', 'attendeeIds', 'createdAt'
                         ]);
        allow update: if isAuthenticated() && isGuildLeaderOrViceLeader(guildId, request.auth.uid) &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.organizerId == resource.data.organizerId && // Organizer shouldn't change easily
                         request.resource.data.createdAt == resource.data.createdAt && // createdAt cannot change
                         request.resource.data.title is string && request.resource.data.title.size() > 0 &&
                         // Add other field validations as in create...
                         // Allow members to update 'attendeeIds' (RSVP - future functionality)
                         (request.resource.data.attendeeIds != resource.data.attendeeIds && isGuildMember(guildId, request.auth.uid) && request.resource.data.attendeeIds is list);
        allow delete: if isAuthenticated() && isGuildLeaderOrViceLeader(guildId, request.auth.uid);
      }

      // Applications subcollection
      match /applications/{applicationId} {
        allow read: if isAuthenticated() && isGuildLeaderOrViceLeader(guildId, request.auth.uid); // Only leaders/vices can read applications
        allow create: if isAuthenticated() && // Applicant creates their own application
                         request.resource.data.guildId == guildId &&
                         request.resource.data.applicantId == request.auth.uid &&
                         request.resource.data.applicantName is string && request.resource.data.applicantName.size() > 0 &&
                         request.resource.data.applicantDisplayName == request.auth.token.name &&
                         request.resource.data.gearScore is number && request.resource.data.gearScore >= 0 &&
                         request.resource.data.gearScoreScreenshotUrl is string && request.resource.data.gearScoreScreenshotUrl.matches('https://.*') &&
                         request.resource.data.discordNick is string && request.resource.data.discordNick.size() > 0 &&
                         request.resource.data.status == 'pending' && // Initial status must be pending or auto_approved for public
                         request.resource.data.submittedAt == request.time &&
                         // TL specific fields (optional if not TL guild)
                         (!('tlRole' in request.resource.data) || request.resource.data.tlRole is string) &&
                         (!('tlPrimaryWeapon' in request.resource.data) || request.resource.data.tlPrimaryWeapon is string) &&
                         (!('tlSecondaryWeapon' in request.resource.data) || request.resource.data.tlSecondaryWeapon is string) &&
                         request.resource.data.keys().hasOnly([
                            'guildId', 'applicantId', 'applicantName', 'applicantDisplayName', 'applicantPhotoURL',
                            'gearScore', 'gearScoreScreenshotUrl', 'discordNick', 'tlRole', 'tlPrimaryWeapon', 'tlSecondaryWeapon',
                            'status', 'submittedAt'
                         ]);
        allow update: if isAuthenticated() && isGuildLeaderOrViceLeader(guildId, request.auth.uid) && // Leaders/Vices can approve/reject
                         request.resource.data.guildId == guildId &&
                         request.resource.data.applicantId == resource.data.applicantId &&
                         request.resource.data.submittedAt == resource.data.submittedAt && // SubmittedAt cannot change
                         request.resource.data.status in ['approved', 'rejected', 'auto_approved'] &&
                         request.resource.data.reviewedBy == request.auth.uid &&
                         request.resource.data.reviewedAt == request.time &&
                         // Ensure other fields are not changed during review
                         request.resource.data.applicantName == resource.data.applicantName &&
                         request.resource.data.gearScore == resource.data.gearScore;
        // No delete for applications by client by default
      }

      // Audit Logs subcollection
      match /auditLogs/{logId} {
        allow read: if isAuthenticated() && isGuildLeaderOrViceLeader(guildId, request.auth.uid); // Only leaders/vices can read audit logs
        allow create: if isAuthenticated() && isGuildLeaderOrViceLeader(guildId, request.auth.uid) && // Audit logs created by server/trusted client actions with role check
                         request.resource.data.actorId == request.auth.uid &&
                         request.resource.data.timestamp == request.time &&
                         request.resource.data.action is string && // TODO: Use enum validation if possible or stricter checks
                         request.resource.data.details is map;
        // No update or delete for audit logs by client
      }

      // Notifications subcollection
      match /notifications/{notificationId} {
        allow read: if isAuthenticated() && isGuildMember(guildId, request.auth.uid); // Members can read notifications
        allow create: if isAuthenticated() && isGuildLeaderOrViceLeader(guildId, request.auth.uid) && // Notifications created by leaders/vices (or system)
                         request.resource.data.guildId == guildId &&
                         request.resource.data.message is string && request.resource.data.message.size() > 0 &&
                         request.resource.data.type is string && // TODO: Enum validation
                         request.resource.data.link is string &&
                         request.resource.data.timestamp == request.time;
        // No update (except maybe isRead by targetUser) or delete by client
        // Allow targetUser to mark as read (future feature)
        // allow update: if isAuthenticated() && request.auth.uid == request.resource.data.targetUserId &&
        //                  request.resource.data.isRead == true &&
        //                  request.resource.data.keys().hasOnly(['isRead']);
      }
    }
  }
}

    
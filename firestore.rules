
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isUserAuthenticated() {
      return request.auth != null;
    }

    function getGuildRolesMap() {
      return {
        Leader: "Líder",
        ViceLeader: "Vice-Líder",
        Counselor: "Conselheiro",
        Officer: "Oficial",
        Member: "Membro"
      };
    }

    function isValidGuildRole(role) {
      return role in getGuildRolesMap().values();
    }

    function getIncomingGuildData() {
      return request.resource.data;
    }

    function getCurrentGuildData() {
      return resource.data;
    }

    function userIsGuildOwner(guildData) {
      return isUserAuthenticated() && request.auth.uid == guildData.ownerId;
    }

    function getUserRole(guildData) {
      if (isUserAuthenticated() && request.auth.uid in guildData.roles) {
        return guildData.roles[request.auth.uid];
      }
      return null;
    }
    
    function isLeaderOrViceLeader(guildData) {
      let userRole = getUserRole(guildData);
      return userRole == getGuildRolesMap().Leader || userRole == getGuildRolesMap().ViceLeader;
    }

    match /guilds/{guildId} {
      allow read: if true;

      allow create: if isUserAuthenticated()
                      && getIncomingGuildData().ownerId == request.auth.uid
                      && getIncomingGuildData().memberIds[0] == request.auth.uid // Criador é o primeiro membro
                      && getIncomingGuildData().memberIds.size() == 1
                      && getIncomingGuildData().memberCount == 1
                      && getIncomingGuildData().name is string 
                      && getIncomingGuildData().name.size() >= 3 && getIncomingGuildData().name.size() <= 50
                      && getIncomingGuildData().roles is map
                      && getIncomingGuildData().roles.size() == 1
                      && request.auth.uid in getIncomingGuildData().roles
                      && getIncomingGuildData().roles[request.auth.uid] == getGuildRolesMap().Leader;

      allow update: if isUserAuthenticated()
                      // Regra 1: Validação geral e campos imutáveis
                      && getIncomingGuildData().name == getCurrentGuildData().name // Nome da guilda não pode mudar por esta regra geral
                      && getIncomingGuildData().createdAt == getCurrentGuildData().createdAt
                      // Regra 2: Validação do campo 'roles' se estiver sendo alterado
                      && (
                        !('roles' in getIncomingGuildData().diff(getCurrentGuildData()).affectedKeys()) || // Se 'roles' não mudou, ou
                        ( // Se 'roles' mudou:
                          getIncomingGuildData().roles is map &&
                          getIncomingGuildData().roles.keys().all(uid => uid is string) && // Todas as chaves são strings (UIDs)
                          getIncomingGuildData().roles.values().all(role => isValidGuildRole(role)) && // Todos os valores são cargos válidos
                          // Deve haver exatamente um líder
                          getIncomingGuildData().roles.values().filter(r => r == getGuildRolesMap().Leader).size() == 1 &&
                          // O ownerId deve ser o UID do líder
                          getIncomingGuildData().roles.keys().filter(uid => getIncomingGuildData().roles[uid] == getGuildRolesMap().Leader)[0] == getIncomingGuildData().ownerId
                        )
                      )
                      // Regra 3: Validação de ownerId (transferência de liderança)
                      && (
                        getIncomingGuildData().ownerId == getCurrentGuildData().ownerId || // Se ownerId não mudou, ou
                        ( // Se ownerId mudou (transferência):
                          getUserRole(getCurrentGuildData()) == getGuildRolesMap().Leader && // Somente o líder atual pode transferir
                          getIncomingGuildData().ownerId != getCurrentGuildData().ownerId &&
                          // O novo ownerId deve ser o novo Líder nos novos roles
                          getIncomingGuildData().roles[getIncomingGuildData().ownerId] == getGuildRolesMap().Leader &&
                          // O antigo ownerId (que é o request.auth.uid) deve ser Vice-Líder nos novos roles
                          getIncomingGuildData().roles[request.auth.uid] == getGuildRolesMap().ViceLeader &&
                           // Garantir que a mudança afetou apenas ownerId e roles (e talvez memberCount, memberIds se o antigo líder saiu)
                           getIncomingGuildData().diff(getCurrentGuildData()).affectedKeys().hasOnly(['ownerId', 'roles'])
                        )
                      )
                      // Regra 4: Validação de memberIds e memberCount
                      && (getIncomingGuildData().memberCount == getIncomingGuildData().memberIds.size())
                      // Regra 5: Permissão para editar campos específicos (banner, logo, description etc.)
                      && (
                        ( // Líder ou Vice-Líder podem editar estes campos
                          isLeaderOrViceLeader(getCurrentGuildData()) &&
                          getIncomingGuildData().diff(getCurrentGuildData()).affectedKeys().hasOnly(['description', 'game', 'password', 'isOpen', 'socialLinks', 'bannerUrl', 'logoUrl', 'tags', 'memberIds', 'memberCount', 'roles', 'ownerId', 'ownerDisplayName'])
                        ) ||
                        ( // Qualquer membro pode se adicionar ou remover (lógica de entrada/saída)
                          // Entrada: usuário se adicionando
                          (
                            getIncomingGuildData().memberIds.size() == getCurrentGuildData().memberIds.size() + 1 &&
                            getIncomingGuildData().memberIds.hasAll(getCurrentGuildData().memberIds) &&
                            getIncomingGuildData().memberIds.hasAny([request.auth.uid]) &&
                            !getCurrentGuildData().memberIds.hasAny([request.auth.uid]) && // Não era membro antes
                            getIncomingGuildData().memberCount == getCurrentGuildData().memberCount + 1 &&
                            // Roles não são alterados por esta operação, exceto para adicionar o novo membro com cargo "Membro"
                            getIncomingGuildData().roles == getCurrentGuildData().roles.merge({[request.auth.uid]: getGuildRolesMap().Member }) &&
                            // Somente memberIds, memberCount e roles (para adicionar o novo membro) podem mudar
                            getIncomingGuildData().diff(getCurrentGuildData()).affectedKeys().hasOnly(['memberIds', 'memberCount', 'roles'])
                          ) ||
                          // Saída: usuário se removendo
                          (
                            getIncomingGuildData().memberIds.size() == getCurrentGuildData().memberIds.size() - 1 &&
                            getCurrentGuildData().memberIds.hasAll(getIncomingGuildData().memberIds) &&
                            !getIncomingGuildData().memberIds.hasAny([request.auth.uid]) &&
                            getCurrentGuildData().memberIds.hasAny([request.auth.uid]) && // Era membro antes
                            getIncomingGuildData().memberCount == getCurrentGuildData().memberCount - 1 &&
                            getIncomingGuildData().roles == getCurrentGuildData().roles.removed([request.auth.uid]) && // Cargo removido
                             // Somente memberIds, memberCount e roles (para remover o membro) podem mudar
                            getIncomingGuildData().diff(getCurrentGuildData()).affectedKeys().hasOnly(['memberIds', 'memberCount', 'roles'])
                          )
                        )
                      );
                      

      allow delete: if isUserAuthenticated()
                      && userIsGuildOwner(getCurrentGuildData()); // Somente o Líder (ownerId) pode deletar
    }

    // TODO: Adicionar regras para 'events', 'achievements', 'applications'
    // Exemplo para events:
    // match /events/{eventId} {
    //   allow read: if true; // ou if isUserAuthenticated()
    //   allow create: if isUserAuthenticated() && 
    //                   userHasPermission(getIncomingEventData().guildId, [getGuildRolesMap().Leader, getGuildRolesMap().ViceLeader, getGuildRolesMap().Counselor, getGuildRolesMap().Officer]);
    //   allow update: if isUserAuthenticated() && 
    //                   userHasPermission(getCurrentEventData().guildId, [getGuildRolesMap().Leader, getGuildRolesMap().ViceLeader, getGuildRolesMap().Counselor, getGuildRolesMap().Officer]);
    //   allow delete: if isUserAuthenticated() && 
    //                   userHasPermission(getCurrentEventData().guildId, [getGuildRolesMap().Leader, getGuildRolesMap().ViceLeader, getGuildRolesMap().Counselor, getGuildRolesMap().Officer]);
    // }
  }
}

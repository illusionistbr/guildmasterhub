
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function getGuildData(guildId) {
      return get(/databases/$(database)/documents/guilds/$(guildId)).data;
    }

    // Assumes guild.roles[userId] is always GuildMemberRoleInfo map or null if not member
    function getUserGeneralRoleInGuild(guildId, userId) {
      let guild = getGuildData(guildId);
      // Check if roles and roles[userId] and roles[userId].generalRole exist
      return guild.roles != null && userId in guild.roles && guild.roles[userId].generalRole != null ? 
             guild.roles[userId].generalRole : 
             null;
    }

    function isOwner(guildId, userId) {
      return isAuthenticated() && getGuildData(guildId).ownerId == userId;
    }

    function isGuildMember(guildId, userId) {
      let guild = getGuildData(guildId);
      return isAuthenticated() && guild.roles != null && userId in guild.roles;
    }

    function isLeader(guildId, userId) {
      return isGuildMember(guildId, userId) && getUserGeneralRoleInGuild(guildId, userId) == 'Líder';
    }

    function isViceLeader(guildId, userId) {
      return isGuildMember(guildId, userId) && getUserGeneralRoleInGuild(guildId, userId) == 'Vice-Líder';
    }

    function isLeaderOrViceLeader(guildId, userId) {
      let role = getUserGeneralRoleInGuild(guildId, userId);
      return role == 'Líder' || role == 'Vice-Líder';
    }

    // Data Validation Functions
    function isValidString(str, min, max) {
      return str is string && str.size() >= min && str.size() <= max;
    }

    function isValidOptionalString(str, max) {
      return (str == null || (str is string && str.size() <= max));
    }

    function isValidUrl(url) {
      // Basic URL check, consider more robust regex if needed
      return url is string && url.matches('^https?://[^\\s/$.?#].[^\\s]*$');
    }
     function isValidOptionalUrl(url) {
      return url == null || isValidUrl(url);
    }

    function isValidTimestamp(ts) {
      return ts is timestamp;
    }
    
    function isWriteTime() { // Use for createdAt, updatedAt
        return request.time;
    }

    function isValidRoleEnum(role) {
      return role in ['Líder', 'Vice-Líder', 'Conselheiro', 'Oficial', 'Membro'];
    }

    function isValidTLRoleEnum(role) {
      return role == null || role in ['Tank', 'Healer', 'DPS'];
    }

    function isValidTLWeaponEnum(weapon) {
      return weapon == null || weapon in ['Sword and Shield', 'Greatsword', 'Daggers', 'Crossbow', 'Bow', 'Staff', 'WandAndTome', 'Spear'];
    }
     function isValidMemberStatusEnum(status) {
      return status == null || status in ['Ativo', 'Inativo', 'Licença'];
    }

    function isValidUserProfileCreateData(data) {
      return data.uid == request.auth.uid
        && data.email == request.auth.token.email
        && isValidString(data.displayName, 2, 50)
        && isValidOptionalUrl(data.photoURL)
        && data.createdAt == request.time
        && data.guilds is list && data.guilds.size() == 0
        && data.lastNotificationsCheckedTimestamp is map && data.lastNotificationsCheckedTimestamp.size() == 0
        && data.keys().hasAll(['uid', 'email', 'displayName', 'photoURL', 'createdAt', 'guilds', 'lastNotificationsCheckedTimestamp'])
        && data.keys().size() == 7; // Ensure no extra fields
    }
    
    function isValidUserProfileUpdateData(newData, oldData) {
        // Immutable fields
        return newData.uid == oldData.uid
            && newData.email == oldData.email
            && newData.createdAt == oldData.createdAt
            // Mutable fields and their validation
            && (newData.displayName == oldData.displayName || isValidString(newData.displayName, 2, 50))
            && (newData.photoURL == oldData.photoURL || isValidOptionalUrl(newData.photoURL))
            && (newData.guilds == oldData.guilds || newData.guilds is list) // Further validation on guild list content if needed
            && (newData.lastNotificationsCheckedTimestamp == oldData.lastNotificationsCheckedTimestamp || newData.lastNotificationsCheckedTimestamp is map)
            // Ensure only allowed fields are present
            && newData.keys().hasOnly(['uid', 'email', 'displayName', 'photoURL', 'createdAt', 'guilds', 'lastNotificationsCheckedTimestamp']);
    }

    function isValidGuildCreateData(data, userId) {
      let ownerRoleInfo = data.roles[userId];
      return data.ownerId == userId
        && isValidString(data.name, 3, 50)
        && isValidOptionalString(data.description, 500)
        && data.memberCount == 1
        && isValidOptionalUrl(data.bannerUrl)
        && isValidOptionalUrl(data.logoUrl)
        && data.memberIds is list && data.memberIds.size() == 1 && data.memberIds[0] == userId
        && isValidOptionalString(data.game, 50)
        && (data.tags == null || (data.tags is list && data.tags.size() <= 10)) // Example: max 10 tags
        && data.createdAt == request.time
        && (data.password == null || (data.password is string && data.password.size() > 0 && data.password.size() <= 50)) // Password if exists must not be empty
        && data.isOpen is bool
        && (data.isOpen == true || data.password != null)
        && (data.socialLinks == null || (data.socialLinks is map && 
            isValidOptionalUrl(data.socialLinks.get('facebook', null)) &&
            isValidOptionalUrl(data.socialLinks.get('x', null)) &&
            isValidOptionalUrl(data.socialLinks.get('youtube', null)) &&
            isValidOptionalUrl(data.socialLinks.get('discord', null)) &&
            data.socialLinks.keys().hasOnly(['facebook', 'x', 'youtube', 'discord'])))
        && data.roles is map && data.roles.size() == 1 && userId in data.roles
        && ownerRoleInfo.generalRole == 'Líder'
        && isValidTLRoleEnum(ownerRoleInfo.get('tlRole', null))
        && isValidTLWeaponEnum(ownerRoleInfo.get('tlPrimaryWeapon', null))
        && isValidTLWeaponEnum(ownerRoleInfo.get('tlSecondaryWeapon', null))
        && isValidMemberStatusEnum(ownerRoleInfo.get('status', 'Ativo')) // Default to Ativo if not present
        && ownerRoleInfo.keys().hasOnly(['generalRole', 'tlRole', 'tlPrimaryWeapon', 'tlSecondaryWeapon', 'notes', 'status'])
        && isValidOptionalString(ownerRoleInfo.get('notes', null), 500)
        && data.keys().hasOnly(['ownerId', 'name', 'description', 'memberCount', 'bannerUrl', 'logoUrl', 'memberIds', 'game', 'tags', 'createdAt', 'password', 'isOpen', 'socialLinks', 'roles', 'ownerDisplayName']);
    }
    
    function isValidGuildUpdateData(newData, oldData, guildId, userId) {
        return isOwner(guildId, userId) // Primary condition: only owner for these general settings
            // Immutable fields that owner cannot change via this generic update
            && newData.ownerId == oldData.ownerId
            && newData.createdAt == oldData.createdAt
            && newData.game == oldData.game // Game should not change
            // Critical fields managed by specific actions, not general update
            && newData.memberIds == oldData.memberIds 
            && newData.memberCount == oldData.memberCount
            && newData.roles == oldData.roles // Role changes are specific operations
            // Mutable fields validation
            && (newData.name == oldData.name || isValidString(newData.name, 3, 50))
            && (newData.description == oldData.description || isValidOptionalString(newData.description, 500))
            && (newData.password == oldData.password || (newData.password == null || (newData.password is string && newData.password.size() > 0 && newData.password.size() <= 50)))
            && (newData.isOpen == oldData.isOpen || newData.isOpen is bool)
            && (newData.isOpen == true || newData.password != null) // If made private, password must exist
            && (newData.bannerUrl == oldData.bannerUrl || isValidOptionalUrl(newData.bannerUrl))
            && (newData.logoUrl == oldData.logoUrl || isValidOptionalUrl(newData.logoUrl))
            && (newData.ownerDisplayName == oldData.ownerDisplayName || isValidString(newData.ownerDisplayName, 2, 50))
            && (newData.socialLinks == oldData.socialLinks || (newData.socialLinks == null || (newData.socialLinks is map &&
                (newData.socialLinks.get('facebook', null) == oldData.socialLinks.get('facebook', null) || isValidOptionalUrl(newData.socialLinks.get('facebook', null))) &&
                (newData.socialLinks.get('x', null) == oldData.socialLinks.get('x', null) || isValidOptionalUrl(newData.socialLinks.get('x', null))) &&
                (newData.socialLinks.get('youtube', null) == oldData.socialLinks.get('youtube', null) || isValidOptionalUrl(newData.socialLinks.get('youtube', null))) &&
                (newData.socialLinks.get('discord', null) == oldData.socialLinks.get('discord', null) || isValidOptionalUrl(newData.socialLinks.get('discord', null))) &&
                newData.socialLinks.keys().hasOnly(['facebook', 'x', 'youtube', 'discord'])))
            )
            && newData.keys().hasOnly(oldData.keys()); // No new fields allowed here
    }


    function isValidEventCreateData(data, guildId) {
      return data.guildId == guildId
        && isValidString(data.title, 3, 100)
        && isValidOptionalString(data.description, 500)
        && data.date is string && data.date.matches('^\\\\d{4}-\\\\d{2}-\\\\d{2}$') // YYYY-MM-DD
        && data.time is string && data.time.matches('^\\\\d{2}:\\\\d{2}$')       // HH:MM
        && (data.endDate == null || (data.endDate is string && data.endDate.matches('^\\\\d{4}-\\\\d{2}-\\\\d{2}$')))
        && (data.endTime == null || (data.endTime is string && data.endTime.matches('^\\\\d{2}:\\\\d{2}$')))
        && isValidOptionalString(data.location, 100)
        && data.organizerId == request.auth.uid
        && (data.attendeeIds == null || (data.attendeeIds is list && data.attendeeIds.size() == 0))
        && (data.dkpValue == null || (data.dkpValue is number && data.dkpValue >= 0 && data.dkpValue <= 1000))
        && data.requiresPin is bool
        && (data.pinCode == null || (data.requiresPin == true && data.pinCode is string && data.pinCode.size() == 6 && data.pinCode.matches('^[0-9]{6}$')))
        && (data.requiresPin == false || data.pinCode != null)
        && data.createdAt == request.time
        && data.keys().hasOnly(['guildId', 'title', 'description', 'date', 'time', 'endDate', 'endTime', 'location', 'organizerId', 'attendeeIds', 'dkpValue', 'requiresPin', 'pinCode', 'createdAt']);
    }

    function isValidEventUpdateData(newData, oldData) {
        return newData.guildId == oldData.guildId
            && newData.organizerId == oldData.organizerId
            && newData.createdAt == oldData.createdAt
            && (newData.title == oldData.title || isValidString(newData.title, 3, 100))
            && (newData.description == oldData.description || isValidOptionalString(newData.description, 500))
            && (newData.date == oldData.date || (newData.date is string && newData.date.matches('^\\\\d{4}-\\\\d{2}-\\\\d{2}$')))
            && (newData.time == oldData.time || (newData.time is string && newData.time.matches('^\\\\d{2}:\\\\d{2}$')))
            && (newData.endDate == oldData.endDate || (newData.endDate == null || (newData.endDate is string && newData.endDate.matches('^\\\\d{4}-\\\\d{2}-\\\\d{2}$'))))
            && (newData.endTime == oldData.endTime || (newData.endTime == null || (newData.endTime is string && newData.endTime.matches('^\\\\d{2}:\\\\d{2}$'))))
            && (newData.location == oldData.location || isValidOptionalString(newData.location, 100))
            && (newData.attendeeIds == oldData.attendeeIds || newData.attendeeIds is list) // More specific validation if needed
            && (newData.dkpValue == oldData.dkpValue || (newData.dkpValue == null || (newData.dkpValue is number && newData.dkpValue >= 0 && newData.dkpValue <= 1000)))
            && (newData.requiresPin == oldData.requiresPin || newData.requiresPin is bool)
            && (newData.pinCode == oldData.pinCode || (newData.pinCode == null || (newData.requiresPin == true && newData.pinCode is string && newData.pinCode.size() == 6 && newData.pinCode.matches('^[0-9]{6}$'))))
            && (newData.requiresPin == false || newData.pinCode != null || newData.pinCode == oldData.pinCode) // If requiresPin is true, pinCode must exist or be the same. If false, pinCode can be nullified.
            && newData.keys().hasOnly(oldData.keys());
    }
    
    function isValidApplicationCreateData(data, guildId) {
        return data.guildId == guildId
            && data.applicantId == request.auth.uid
            && isValidString(data.applicantName, 2, 50)
            && isValidString(data.applicantDisplayName, 2, 50)
            && isValidOptionalUrl(data.applicantPhotoURL)
            && data.gearScore is number && data.gearScore >= 0 && data.gearScore <= 10000
            && isValidUrl(data.gearScoreScreenshotUrl)
            && isValidTLRoleEnum(data.tlRole)
            && isValidTLWeaponEnum(data.tlPrimaryWeapon)
            && isValidTLWeaponEnum(data.tlSecondaryWeapon)
            && isValidString(data.discordNick, 2, 50)
            && data.status == 'pending'
            && data.submittedAt == request.time
            && data.keys().hasOnly(['guildId', 'applicantId', 'applicantName', 'applicantDisplayName', 'applicantPhotoURL', 'gearScore', 'gearScoreScreenshotUrl', 'tlRole', 'tlPrimaryWeapon', 'tlSecondaryWeapon', 'discordNick', 'status', 'submittedAt']);
    }

    function isValidApplicationUpdateData(newData, oldData) { // Only for status update by admin
        return newData.guildId == oldData.guildId
            && newData.applicantId == oldData.applicantId
            && newData.applicantName == oldData.applicantName
            && newData.applicantDisplayName == oldData.applicantDisplayName
            && newData.applicantPhotoURL == oldData.applicantPhotoURL
            && newData.gearScore == oldData.gearScore
            && newData.gearScoreScreenshotUrl == oldData.gearScoreScreenshotUrl
            && newData.tlRole == oldData.tlRole
            && newData.tlPrimaryWeapon == oldData.tlPrimaryWeapon
            && newData.tlSecondaryWeapon == oldData.tlSecondaryWeapon
            && newData.discordNick == oldData.discordNick
            && newData.submittedAt == oldData.submittedAt
            // Mutable fields
            && (newData.status in ['approved', 'rejected'])
            && newData.reviewedBy == request.auth.uid
            && newData.reviewedAt == request.time
            && newData.keys().hasOnly(oldData.keys().concat(['reviewedBy', 'reviewedAt'])); // only status, reviewedBy, reviewedAt can be added/changed
    }

    function isValidAuditLogCreateData(data) {
        return data.timestamp == request.time
            && data.actorId is string 
            && isValidOptionalString(data.actorDisplayName, 50)
            && data.action is string 
            && data.details is map
            && data.keys().hasOnly(['timestamp', 'actorId', 'actorDisplayName', 'action', 'details']);
    }

    function isValidNotificationCreateData(data) {
        return data.guildId is string
            && isValidString(data.message, 1, 500)
            && data.type is string
            && data.link is string // Could be URL or path
            && data.timestamp == request.time
            && (data.details == null || data.details is map)
            && (data.createdByUserId == null || data.createdByUserId is string)
            && (data.createdByUserDisplayname == null || isValidOptionalString(data.createdByUserDisplayname, 50))
            && (data.targetUserId == null || data.targetUserId is string)
            && (data.isRead == null || data.isRead == false) // isRead should be false on creation
            && data.keys().hasOnly(['guildId', 'message', 'type', 'link', 'timestamp', 'details', 'createdByUserId', 'createdByUserDisplayname', 'targetUserId', 'isRead']);
    }


    // User Profiles
    match /users/{userId} {
      allow read: if isAuthenticated() && request.auth.uid == userId;
      allow create: if isAuthenticated() && request.auth.uid == userId 
                    && isValidUserProfileCreateData(request.resource.data);
      allow update: if isAuthenticated() && request.auth.uid == userId
                    && isValidUserProfileUpdateData(request.resource.data, resource.data);
      allow delete: if false; 
    }

    // Guilds
    match /guilds/{guildId} {
      allow read: if isAuthenticated() && (isGuildMember(guildId, request.auth.uid) || getGuildData(guildId).isOpen == true);
      allow create: if isAuthenticated() 
                    && request.auth.uid == request.resource.data.ownerId
                    && isValidGuildCreateData(request.resource.data, request.auth.uid);
      allow update: if isAuthenticated()
                    && isValidGuildUpdateData(request.resource.data, resource.data, guildId, request.auth.uid);
                    // TODO: Separate rules for member management actions (join, leave, role change) by Leader/ViceLeader.
                    // Those would typically modify memberIds, memberCount, and roles fields.
      allow delete: if isAuthenticated() && isOwner(guildId, request.auth.uid);

      // Subcollection: Events
      match /events/{eventId} {
        allow read: if isAuthenticated() && isGuildMember(guildId, request.auth.uid);
        allow create: if isAuthenticated() && isLeaderOrViceLeader(guildId, request.auth.uid)
                      && isValidEventCreateData(request.resource.data, guildId);
        allow update: if isAuthenticated() && isLeaderOrViceLeader(guildId, request.auth.uid)
                      && isValidEventUpdateData(request.resource.data, resource.data);
        allow delete: if isAuthenticated() && isLeaderOrViceLeader(guildId, request.auth.uid);
      }

      // Subcollection: Applications
      match /applications/{applicationId} {
        allow read: if isAuthenticated() && 
                      (isLeaderOrViceLeader(guildId, request.auth.uid) || request.auth.uid == resource.data.applicantId); // Applicant can read their own
        allow create: if isAuthenticated() 
                      && request.resource.data.applicantId == request.auth.uid
                      && isValidApplicationCreateData(request.resource.data, guildId);
        allow update: if isAuthenticated() && isLeaderOrViceLeader(guildId, request.auth.uid)
                      && isValidApplicationUpdateData(request.resource.data, resource.data);
        allow delete: if false;
      }

      // Subcollection: Audit Logs
      match /auditLogs/{logId} {
        allow read: if isAuthenticated() && isLeaderOrViceLeader(guildId, request.auth.uid);
        allow create: if isAuthenticated() && isValidAuditLogCreateData(request.resource.data)
                      && (isLeaderOrViceLeader(guildId, request.auth.uid) || request.auth.uid == request.resource.data.actorId);
        allow update: if false;
        allow delete: if false;
      }

      // Subcollection: Notifications
      match /notifications/{notificationId} {
        allow read: if isAuthenticated() && isGuildMember(guildId, request.auth.uid);
        allow create: if isAuthenticated() && isLeaderOrViceLeader(guildId, request.auth.uid)
                      && isValidNotificationCreateData(request.resource.data);
        // Update for 'isRead' by target user could be added here.
        // e.g. allow update: if isAuthenticated() && request.auth.uid == resource.data.targetUserId && request.resource.data.keys().hasOnly(['isRead']);
        allow update: if false; 
        allow delete: if false;
      }
    }
  }
}

    
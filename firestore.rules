
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user is a member of a guild
    function isGuildMember(guildId, userId) {
      let guildDoc = get(/databases/$(database)/documents/guilds/$(guildId));
      return guildDoc.exists && guildDoc.data.memberIds is list && userId in guildDoc.data.memberIds;
    }

    // Helper function to get a user's role name in a guild
    function getUserRoleName(guildId, userId) {
      let guildDoc = get(/databases/$(database)/documents/guilds/$(guildId));
      if (!guildDoc.exists || !(userId in guildDoc.data.roles)) {
        return null;
      }
      return guildDoc.data.roles[userId].roleName;
    }

    // Helper function to check specific permission for a user in a guild
    function hasGuildPermission(guildId, userId, permission) {
      let guildDoc = get(/databases/$(database)/documents/guilds/$(guildId));
      if (!guildDoc.exists || request.auth == null) {
        return false;
      }
      let guildData = guildDoc.data;
      // Owner has all permissions implicitly for this model
      if (guildData.ownerId == userId) {
        return true;
      }
      // Check if user has a role defined in the guild
      if (!(userId in guildData.roles)) {
        return false; // User not found in guild roles
      }
      let roleName = guildData.roles[userId].roleName;
      // Check if the role exists in customRoles and has permissions defined
      if (roleName == null || !(roleName in guildData.customRoles) ||
          !('permissions' in guildData.customRoles[roleName]) ||
          !(guildData.customRoles[roleName].permissions is list)) {
        return false; // Role or permissions not defined correctly
      }
      // Check if the required permission is in the role's permission list
      return guildData.customRoles[roleName].permissions.hasAny([permission]);
    }

    // Users Collection
    match /users/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId
                      && request.resource.data.uid == userId; // Ensure user creates their own doc
      allow update: if request.auth != null && request.auth.uid == userId
                      // Prevent changing critical immutable fields
                      && !(request.resource.data.uid != resource.data.uid)
                      && !(request.resource.data.email != resource.data.email)
                      && !(request.resource.data.createdAt != resource.data.createdAt)
                      // Allow updating lastNotificationsCheckedTimestamp
                      && (request.resource.data.keys().hasOnly(['displayName', 'photoURL', 'guilds', 'lastNotificationsCheckedTimestamp'])
                          || request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastNotificationsCheckedTimestamp', 'displayName', 'photoURL']));
    }

    // Guilds Collection
    match /guilds/{guildId} {
      allow read: if request.auth != null; // Authenticated users can read guild list for discovery

      allow create: if request.auth != null
                      && request.resource.data.ownerId == request.auth.uid
                      && request.resource.data.name is string && request.resource.data.name.size() >= 3
                      && request.resource.data.game is string && request.resource.data.game.size() >= 1
                      && request.resource.data.memberCount == 1
                      && request.resource.data.memberIds is list && request.resource.data.memberIds[0] == request.auth.uid
                      && request.resource.data.roles[request.auth.uid].roleName == "Lider";

      allow update: if request.auth != null &&
                  (
                    // Owner can update general guild settings, roles, permissions etc.
                    (resource.data.ownerId == request.auth.uid &&
                      // Prevent owner from accidentally changing ownerId or createdAt
                      request.resource.data.ownerId == resource.data.ownerId &&
                      request.resource.data.createdAt == resource.data.createdAt
                    ) ||
                    // Member can update their own specific role info (e.g., nickname, gearScore)
                    (
                      isGuildMember(guildId, request.auth.uid) &&
                      // Check that only the member's own entry in the roles map is being modified for specific fields
                      request.resource.data.roles[request.auth.uid].diff(resource.data.roles[request.auth.uid]).affectedKeys().hasOnly([
                        'characterNickname', 'gearScore', 'gearScoreScreenshotUrl', 'gearBuildLink', 'skillBuildLink', 'tlRole', 'tlPrimaryWeapon', 'tlSecondaryWeapon', 'notes', 'status'
                        // DKP balance updates are handled by event PIN submission or admin actions
                      ]) &&
                      // Ensure critical parts of their role entry are not changed by them here (like roleName or dkpBalance decrement)
                      request.resource.data.roles[request.auth.uid].roleName == resource.data.roles[request.auth.uid].roleName &&
                      (request.resource.data.roles[request.auth.uid].dkpBalance == resource.data.roles[request.auth.uid].dkpBalance || request.resource.data.roles[request.auth.uid].dkpBalance > resource.data.roles[request.auth.uid].dkpBalance) &&
                      // Ensure only their own 'roles' entry is part of the change to the 'roles' map.
                      request.resource.data.roles.diff(resource.data.roles).affectedKeys().hasOnly([request.auth.uid]) &&
                      // Ensure no other top-level guild fields are changed by the member
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles'])
                    ) ||
                    // Member joining/leaving via application processing or public join (updates memberIds, memberCount, roles)
                    // This is simplified; ideally, application acceptance would be a Cloud Function or more specific rule.
                    (
                        (hasGuildPermission(guildId, request.auth.uid, "MANAGE_RECRUITMENT_PROCESS_APPLICATIONS") || resource.data.isOpen == true) &&
                        (request.resource.data.memberIds != resource.data.memberIds || request.resource.data.memberCount != resource.data.memberCount || request.resource.data.roles != resource.data.roles)
                    )
                  );

      allow delete: if request.auth != null && resource.data.ownerId == request.auth.uid;

      // --- Guild Subcollections ---

      match /applications/{applicationId} {
        allow read: if request.auth != null && (
                      hasGuildPermission(guildId, request.auth.uid, "MANAGE_RECRUITMENT_VIEW_APPLICATIONS") ||
                      request.auth.uid == resource.data.applicantId // Applicant can view their own application
                    );
        allow create: if request.auth != null && request.resource.data.applicantId == request.auth.uid
                        && request.resource.data.guildId == guildId;
        allow update: if request.auth != null && hasGuildPermission(guildId, request.auth.uid, "MANAGE_RECRUITMENT_PROCESS_APPLICATIONS")
                         // Can only update status, reviewedBy, reviewedAt
                         && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'reviewedBy', 'reviewedAt']);
        allow delete: if false; // Applications generally shouldn't be deleted by client
      }

      match /auditLogs/{logId} {
        allow read: if request.auth != null && hasGuildPermission(guildId, request.auth.uid, "VIEW_AUDIT_LOG");
        allow create: if request.auth != null && request.resource.data.actorId == request.auth.uid
                        && request.resource.data.guildId == guildId; // Assuming guildId is part of log for completeness
        allow update, delete: if false; // Logs are immutable
      }

      match /events/{eventId} {
        allow read: if request.auth != null && isGuildMember(guildId, request.auth.uid);
        allow create: if request.auth != null && hasGuildPermission(guildId, request.auth.uid, "MANAGE_EVENTS_CREATE")
                        && request.resource.data.organizerId == request.auth.uid
                        && request.resource.data.guildId == guildId;
        allow update: if request.auth != null &&
                      (
                        (hasGuildPermission(guildId, request.auth.uid, "MANAGE_EVENTS_EDIT") || resource.data.organizerId == request.auth.uid) ||
                        // Allow member to add themselves to attendeesWithPin if they are a member (client validates PIN)
                        (
                          isGuildMember(guildId, request.auth.uid) &&
                          request.resource.data.attendeesWithPin is list &&
                          resource.data.attendeesWithPin is list &&
                          request.resource.data.attendeesWithPin.size() == resource.data.attendeesWithPin.size() + 1 &&
                          request.auth.uid in request.resource.data.attendeesWithPin &&
                          // Ensure only attendeesWithPin is changed
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendeesWithPin'])
                        )
                      );
        allow delete: if request.auth != null &&
                        (hasGuildPermission(guildId, request.auth.uid, "MANAGE_EVENTS_DELETE") || resource.data.organizerId == request.auth.uid);
      }

      match /groups/{groupId} {
        allow read: if request.auth != null && isGuildMember(guildId, request.auth.uid);
        allow create: if request.auth != null && hasGuildPermission(guildId, request.auth.uid, "MANAGE_GROUPS_CREATE")
                        && request.resource.data.createdBy == request.auth.uid
                        && request.resource.data.guildId == guildId;
        allow update: if request.auth != null && hasGuildPermission(guildId, request.auth.uid, "MANAGE_GROUPS_EDIT");
        allow delete: if request.auth != null && hasGuildPermission(guildId, request.auth.uid, "MANAGE_GROUPS_DELETE");
      }

      match /notifications/{notificationId} {
        allow read: if request.auth != null && isGuildMember(guildId, request.auth.uid);
        allow create: if request.auth != null && request.resource.data.createdByUserId == request.auth.uid
                        && request.resource.data.guildId == guildId;
        allow update: if false; // For now, make notifications immutable by client
        allow delete: if false;
      }

      match /dkpDecayLogs/{logId} {
        allow read: if request.auth != null && get(/databases/$(database)/documents/guilds/$(guildId)).data.ownerId == request.auth.uid;
        allow create: if request.auth != null && get(/databases/$(database)/documents/guilds/$(guildId)).data.ownerId == request.auth.uid
                        && request.resource.data.triggeredByUserId == request.auth.uid
                        && request.resource.data.guildId == guildId;
        allow update, delete: if false;
      }
    }
  }
}

    

rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function getGuildData(guildId) {
      return get(/databases/$(database)/documents/guilds/$(guildId)).data;
    }

    function isGuildOwner(guildId, userId) {
      let guild = getGuildData(guildId);
      return guild.ownerId == userId;
    }

    function getUserRoleInGuild(guildId, userId) {
      let guild = getGuildData(guildId);
      if (guild.roles != null && userId in guild.roles) {
        // If roles[userId] is a map (new structure)
        if (guild.roles[userId] is map && 'generalRole' in guild.roles[userId]) {
          return guild.roles[userId].generalRole;
        }
        // If roles[userId] is a string (older structure, for compatibility if needed)
        if (guild.roles[userId] is string) {
          return guild.roles[userId];
        }
      }
      return null;
    }

    function isGuildLeader(guildId, userId) {
      return getUserRoleInGuild(guildId, userId) == 'Líder';
    }

    function isGuildViceLeader(guildId, userId) {
      return getUserRoleInGuild(guildId, userId) == 'Vice-Líder';
    }

    function isGuildOfficerOrHigher(guildId, userId) {
      let role = getUserRoleInGuild(guildId, userId);
      return role == 'Líder' || role == 'Vice-Líder' || role == 'Oficial';
    }

    function isGuildMember(guildId, userId) {
      let guild = getGuildData(guildId);
      return guild.memberIds != null && userId in guild.memberIds;
    }

    // User Profiles
    match /users/{userId} {
      allow read: if isAuthenticated(); // Allow any authenticated user to read profiles (e.g., for member lists)
                       // Or, for stricter privacy: if isUser(userId);
      allow create: if isUser(userId) &&
                       request.resource.data.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       (request.resource.data.displayName is string || request.resource.data.displayName == null) &&
                       (request.resource.data.photoURL is string || request.resource.data.photoURL == null) &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.guilds is list && request.resource.data.guilds.size() == 0 &&
                       request.resource.data.lastNotificationsCheckedTimestamp is map && request.resource.data.lastNotificationsCheckedTimestamp.size() == 0;

      allow update: if isUser(userId) &&
                       // User cannot change their own uid, email, or createdAt
                       !('uid' in request.resource.data && request.resource.data.uid != resource.data.uid) &&
                       !('email' in request.resource.data && request.resource.data.email != resource.data.email) &&
                       !('createdAt' in request.resource.data && request.resource.data.createdAt != resource.data.createdAt) &&
                       // Validate updated fields
                       (request.resource.data.keys().hasOnly(['displayName', 'photoURL', 'guilds', 'lastNotificationsCheckedTimestamp'])) &&
                       (request.resource.data.containsKey('displayName') ? (request.resource.data.displayName is string || request.resource.data.displayName == null) : true) &&
                       (request.resource.data.containsKey('photoURL') ? (request.resource.data.photoURL is string || request.resource.data.photoURL == null) : true) &&
                       (request.resource.data.containsKey('guilds') ? request.resource.data.guilds is list : true) && // Guilds list might be updated by server functions
                       (request.resource.data.containsKey('lastNotificationsCheckedTimestamp') ?
                          request.resource.data.lastNotificationsCheckedTimestamp is map &&
                          // Allow updating specific keys within the map to a timestamp
                          request.resource.data.lastNotificationsCheckedTimestamp.keys().size() == resource.data.lastNotificationsCheckedTimestamp.keys().size() + 1 ||
                          request.resource.data.lastNotificationsCheckedTimestamp.diff(resource.data.lastNotificationsCheckedTimestamp).affectedKeys().size() == 1 &&
                          request.resource.data.lastNotificationsCheckedTimestamp.diff(resource.data.lastNotificationsCheckedTimestamp).affectedKeys()[0] is string &&
                          request.resource.data.lastNotificationsCheckedTimestamp[request.resource.data.lastNotificationsCheckedTimestamp.diff(resource.data.lastNotificationsCheckedTimestamp).affectedKeys()[0]] is timestamp
                        : true);
      allow delete: if false; // Generally, users don't delete their own accounts via Firestore directly
    }

    // Guilds
    match /guilds/{guildId} {
      allow read: if isAuthenticated(); // Any authenticated user can read guild listings

      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50 &&
                       (request.resource.data.description is string || request.resource.data.description == null) &&
                       request.resource.data.game is string && request.resource.data.game.size() > 0 &&
                       request.resource.data.memberCount == 1 &&
                       request.resource.data.memberIds[0] == request.auth.uid &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.roles[request.auth.uid] is map &&
                       request.resource.data.roles[request.auth.uid].generalRole == 'Líder' &&
                       // Ensure other optional fields are of correct type if present
                       (request.resource.data.containsKey('password') ? request.resource.data.password is string || request.resource.data.password == null : true) &&
                       (request.resource.data.containsKey('isOpen') ? request.resource.data.isOpen is bool : true) &&
                       (request.resource.data.containsKey('bannerUrl') ? request.resource.data.bannerUrl is string || request.resource.data.bannerUrl == null : true) &&
                       (request.resource.data.containsKey('logoUrl') ? request.resource.data.logoUrl is string || request.resource.data.logoUrl == null : true) &&
                       (request.resource.data.containsKey('socialLinks') ? request.resource.data.socialLinks is map : true);


      allow update: if isAuthenticated() && isGuildOwner(guildId, request.auth.uid) || isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid) {
                      // Owner/Leader can update core details like name, description, game, password, visibility, banner, logo
                      if (isGuildOwner(guildId, request.auth.uid) || isGuildLeader(guildId, request.auth.uid)) {
                        // Fields owner/leader can change:
                        let allowedFields = ['name', 'description', 'game', 'password', 'isOpen', 'bannerUrl', 'logoUrl', 'socialLinks'];
                        // Fields related to members/roles that have specific logic below
                        let memberRelatedFields = ['memberIds', 'memberCount', 'roles'];

                        // Check if only allowed fields are being updated, or member-related fields (which have their own checks)
                        (request.resource.data.keys().hasOnly(allowedFields.concat(memberRelatedFields))) &&
                        (request.resource.data.containsKey('name') ? request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50 : true) &&
                        (request.resource.data.containsKey('description') ? request.resource.data.description is string || request.resource.data.description == null : true) &&
                        (request.resource.data.containsKey('password') ? request.resource.data.password is string || request.resource.data.password == null : true) &&
                        (request.resource.data.containsKey('isOpen') ? request.resource.data.isOpen is bool : true) &&
                        // Banner and Logo update by Owner
                        (request.resource.data.containsKey('bannerUrl') ? request.resource.data.bannerUrl is string && isGuildOwner(guildId, request.auth.uid) : true) &&
                        (request.resource.data.containsKey('logoUrl') ? request.resource.data.logoUrl is string && isGuildOwner(guildId, request.auth.uid) : true) &&
                        // Social Links can be updated by owner/leader
                        (request.resource.data.containsKey('socialLinks') ? request.resource.data.socialLinks is map : true)
                      }

                      // Logic for member joining (e.g., accepting application or direct join to public guild)
                      // memberIds: adding a new member
                      // memberCount: incrementing
                      // roles: adding a new member's role
                      if (request.resource.data.containsKey('memberIds') && request.resource.data.memberIds.size() == resource.data.memberIds.size() + 1) {
                         (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid)) && // Leader/Vice can accept
                         request.resource.data.memberCount == resource.data.memberCount + 1 &&
                         // Check the new role being added
                         let newMemberId = request.resource.data.memberIds.diff(resource.data.memberIds).added()[0];
                         request.resource.data.roles[newMemberId] is map &&
                         request.resource.data.roles[newMemberId].generalRole == 'Membro' // New members join as "Membro"
                      }
                      // Logic for member leaving/kicked
                      // memberIds: removing a member
                      // memberCount: decrementing
                      // roles: removing a member's role (key deleted)
                      else if (request.resource.data.containsKey('memberIds') && request.resource.data.memberIds.size() == resource.data.memberIds.size() - 1) {
                         let removedMemberId = resource.data.memberIds.diff(request.resource.data.memberIds).removed()[0];
                         let removedMemberRole = getUserRoleInGuild(guildId, removedMemberId);
                         // Leader can kick anyone except self. Vice can kick Officer/Counselor/Member.
                         (isGuildLeader(guildId, request.auth.uid) && removedMemberId != request.auth.uid) ||
                         (isGuildViceLeader(guildId, request.auth.uid) && (removedMemberRole == 'Oficial' || removedMemberRole == 'Conselheiro' || removedMemberRole == 'Membro')) &&
                         request.resource.data.memberCount == resource.data.memberCount - 1 &&
                         !(removedMemberId in request.resource.data.roles) // Role entry is removed
                      }
                      // Logic for role change
                      else if (request.resource.data.containsKey('roles')) {
                        let affectedRoleKeys = request.resource.data.roles.diff(resource.data.roles).affectedKeys();
                        affectedRoleKeys.size() == 1 && // Only one role change at a time for simplicity in rules
                        let changedUserId = affectedRoleKeys[0];
                        let oldRole = getUserRoleInGuild(guildId, changedUserId);
                        let newRole = request.resource.data.roles[changedUserId].generalRole;
                        // Leader can change any role except their own (must transfer ownership)
                        (isGuildLeader(guildId, request.auth.uid) && changedUserId != request.auth.uid && newRole != 'Líder') ||
                        // Vice can change roles of Counselor, Officer, Member to Counselor, Officer, Member
                        (isGuildViceLeader(guildId, request.auth.uid) &&
                          (oldRole == 'Conselheiro' || oldRole == 'Oficial' || oldRole == 'Membro') &&
                          (newRole == 'Conselheiro' || newRole == 'Oficial' || newRole == 'Membro')
                        ) &&
                        // Ensure the role structure is correct
                        request.resource.data.roles[changedUserId] is map &&
                        request.resource.data.roles[changedUserId].generalRole is string &&
                        // Prevent self-promotion or demotion for simplicity here, handle complex cases via functions if needed
                        changedUserId != request.auth.uid || (oldRole == newRole && request.resource.data.roles[changedUserId].keys().hasAny(['notes', 'tlRole', 'tlPrimaryWeapon', 'tlSecondaryWeapon', 'status']))


                      } else {
                        // If none of the specific member/role changes occurred, assume it's a general guild setting update.
                        // The initial field checks for owner/leader cover these.
                        true
                      }
                    } else {
                      false // Default deny if not owner/leader/vice
                    }
      }

      allow delete: if isAuthenticated() && isGuildOwner(guildId, request.auth.uid); // Only owner can delete the guild

      // Guild Subcollections

      // Applications
      match /applications/{applicationId} {
        allow read: if isAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid));
        allow create: if isAuthenticated() &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.applicantId == request.auth.uid &&
                         request.resource.data.applicantName is string &&
                         request.resource.data.gearScore is number &&
                         request.resource.data.gearScoreScreenshotUrl is string && // Consider URL validation
                         request.resource.data.discordNick is string &&
                         request.resource.data.status == 'pending' &&
                         request.resource.data.submittedAt == request.time &&
                         // Ensure user is not already a member
                         !isGuildMember(guildId, request.auth.uid);
        allow update: if isAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid)) &&
                         // Can only update status, reviewedBy, reviewedAt
                         request.resource.data.keys().hasOnly(['status', 'reviewedBy', 'reviewedAt']) &&
                         (request.resource.data.status == 'approved' || request.resource.data.status == 'rejected') &&
                         request.resource.data.reviewedBy == request.auth.uid &&
                         request.resource.data.reviewedAt == request.time &&
                         // Ensure original data is not tampered with
                         request.resource.data.guildId == resource.data.guildId &&
                         request.resource.data.applicantId == resource.data.applicantId;
        allow delete: if false; // Applications are generally not deleted, just status updated
      }

      // Events
      match /events/{eventId} {
        allow read: if isAuthenticated() && isGuildMember(guildId, request.auth.uid); // Any guild member can read events
        allow create: if isAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid) || isGuildOfficerOrHigher(guildId, request.auth.uid)) &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.title is string && request.resource.data.title.size() > 0 &&
                         request.resource.data.date is string && // Consider date format validation
                         request.resource.data.time is string && // Consider time format validation
                         request.resource.data.organizerId == request.auth.uid &&
                         request.resource.data.createdAt == request.time &&
                         (request.resource.data.containsKey('description') ? request.resource.data.description is string : true) &&
                         (request.resource.data.containsKey('endDate') ? request.resource.data.endDate is string : true) &&
                         (request.resource.data.containsKey('endTime') ? request.resource.data.endTime is string : true) &&
                         (request.resource.data.containsKey('location') ? request.resource.data.location is string : true) &&
                         (request.resource.data.containsKey('dkpValue') ? request.resource.data.dkpValue is number : true) &&
                         (request.resource.data.containsKey('requiresPin') ? request.resource.data.requiresPin is bool : true) &&
                         (request.resource.data.containsKey('pinCode') ? request.resource.data.pinCode is string && request.resource.data.pinCode.size() == 6 : true);

        allow update: if isAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid) || isGuildOfficerOrHigher(guildId, request.auth.uid)) &&
                         // Allow updating all mutable fields except guildId and organizerId
                         request.resource.data.guildId == resource.data.guildId &&
                         request.resource.data.organizerId == resource.data.organizerId &&
                         request.resource.data.createdAt == resource.data.createdAt; // createdAt should not change
                         // Add specific field validations as in create if needed

        allow delete: if isAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid) || isGuildOfficerOrHigher(guildId, request.auth.uid));
      }

      // Audit Logs
      match /auditLogs/{logId} {
        allow read: if isAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid));
        allow create: if isAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid) || isGuildOfficerOrHigher(guildId, request.auth.uid) || request.auth.uid == request.resource.data.actorId ) && // System/user actions can create logs
                         request.resource.data.actorId is string &&
                         request.resource.data.action is string &&
                         request.resource.data.timestamp == request.time &&
                         (request.resource.data.details is map || request.resource.data.details == null);
        allow update: if false; // Logs are immutable
        allow delete: if false; // Logs are immutable
      }

      // Notifications
      match /notifications/{notificationId} {
        allow read: if isAuthenticated() && isGuildMember(guildId, request.auth.uid); // Members can read notifications for their guild
        allow create: if isAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid) || isGuildOfficerOrHigher(guildId, request.auth.uid)) && // Officers or higher can create notifications
                         request.resource.data.guildId == guildId &&
                         request.resource.data.message is string &&
                         request.resource.data.type is string &&
                         request.resource.data.link is string &&
                         request.resource.data.timestamp == request.time;
        allow update: if false; // Notifications are generally immutable or have specific update logic (e.g., isRead status by the target user)
                         // For isRead status:
                         // if isAuthenticated() && request.auth.uid == resource.data.targetUserId &&
                         //    request.resource.data.keys().hasOnly(['isRead']) && request.resource.data.isRead == true;
        allow delete: if isAuthenticated() && (isGuildLeader(guildId, request.auth.uid) || isGuildViceLeader(guildId, request.auth.uid)); // Admins can delete notifications
      }
    }
  }
}

    
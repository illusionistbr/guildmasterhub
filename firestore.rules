
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper: Is the requesting user the owner of the guild document being evaluated?
    function isOwner(guildDoc) {
      return guildDoc.ownerId == request.auth.uid;
    }

    // Helper: Is the requesting user a member of the guild document being evaluated?
    function isMember(guildDoc) {
      return request.auth.uid in guildDoc.memberIds;
    }

    // Helper: Does the requesting user have a specific permission in the guild document being evaluated?
    function hasPermission(guildDoc, permission) {
      // Check if the user's ID exists in the roles map
      return request.auth.uid in guildDoc.roles &&
             // Check if the roleName for the user exists in the customRoles map
             guildDoc.roles[request.auth.uid].roleName in guildDoc.customRoles &&
             // Check if the permissions list exists for that role and contains the required permission
             guildDoc.customRoles[guildDoc.roles[request.auth.uid].roleName].permissions.hasAny([permission]);
    }

    match /guilds/{guildId} {
      // Read: Authenticated members can read their guild.
      allow read: if request.auth != null && isMember(resource.data);

      // Create: Any authenticated user can create a guild.
      // - ownerId must be the creator's UID.
      // - memberIds must contain the ownerId.
      // - memberCount must be 1.
      // - roles must contain an entry for the owner with role "Lider".
      // - customRoles must contain "Lider" (all permissions) and "Membro" (default view permissions).
      allow create: if request.auth != null &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.auth.uid in request.resource.data.memberIds &&
                       request.resource.data.memberCount == 1 &&
                       request.auth.uid in request.resource.data.roles &&
                       request.resource.data.roles[request.auth.uid].roleName == "Lider" &&
                       "Lider" in request.resource.data.customRoles &&
                       "Membro" in request.resource.data.customRoles &&
                       request.resource.data.customRoles["Lider"].permissions.hasAll(["MANAGE_MEMBERS_VIEW", "MANAGE_MEMBERS_EDIT_ROLE", "MANAGE_MEMBERS_EDIT_STATUS", "MANAGE_MEMBERS_EDIT_NOTES", "MANAGE_MEMBERS_KICK", "MANAGE_EVENTS_CREATE", "MANAGE_EVENTS_EDIT", "MANAGE_EVENTS_DELETE", "MANAGE_EVENTS_VIEW_PIN", "MANAGE_GUILD_SETTINGS_GENERAL", "MANAGE_GUILD_SETTINGS_APPEARANCE", "MANAGE_ROLES_PERMISSIONS", "MANAGE_GROUPS_CREATE", "MANAGE_GROUPS_EDIT", "MANAGE_GROUPS_DELETE", "VIEW_AUDIT_LOG", "MANAGE_RECRUITMENT_VIEW_APPLICATIONS", "MANAGE_RECRUITMENT_PROCESS_APPLICATIONS", "VIEW_MEMBER_DETAILED_INFO"]) &&
                       request.resource.data.customRoles["Membro"].permissions.hasAll(["MANAGE_MEMBERS_VIEW", "VIEW_MEMBER_DETAILED_INFO"]);

      // Update: Complex logic for updates.
      allow update: if request.auth != null && isMember(resource.data) && (
                      // Case 1: Guild Owner making general updates (cannot change ownerId)
                      (isOwner(resource.data) && request.resource.data.ownerId == resource.data.ownerId) ||

                      // Case 2: Updating specific fields based on permissions
                      (hasPermission(resource.data, "MANAGE_GUILD_SETTINGS_GENERAL") &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['name', 'description', 'password', 'isOpen', 'game', 'region', 'server', 'tags', 'socialLinks', 'recruitmentQuestions', 'dkpSystemEnabled', 'dkpRedemptionWindow', 'dkpDefaultsPerCategory', 'dkpDecayEnabled', 'dkpDecayPercentage', 'dkpDecayIntervalDays', 'dkpDecayInitialDate'])
                      ) ||
                      (hasPermission(resource.data, "MANAGE_GUILD_SETTINGS_APPEARANCE") &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['bannerUrl', 'logoUrl'])
                      ) ||
                      (hasPermission(resource.data, "MANAGE_ROLES_PERMISSIONS") &&
                        request.resource.data.customRoles != resource.data.customRoles &&
                        "Lider" in request.resource.data.customRoles && // Lider role must exist
                        "Membro" in request.resource.data.customRoles && // Membro role must exist
                        request.resource.data.customRoles["Lider"].permissions.hasAll(["MANAGE_MEMBERS_VIEW", "MANAGE_MEMBERS_EDIT_ROLE", "MANAGE_MEMBERS_EDIT_STATUS", "MANAGE_MEMBERS_EDIT_NOTES", "MANAGE_MEMBERS_KICK", "MANAGE_EVENTS_CREATE", "MANAGE_EVENTS_EDIT", "MANAGE_EVENTS_DELETE", "MANAGE_EVENTS_VIEW_PIN", "MANAGE_GUILD_SETTINGS_GENERAL", "MANAGE_GUILD_SETTINGS_APPEARANCE", "MANAGE_ROLES_PERMISSIONS", "MANAGE_GROUPS_CREATE", "MANAGE_GROUPS_EDIT", "MANAGE_GROUPS_DELETE", "VIEW_AUDIT_LOG", "MANAGE_RECRUITMENT_VIEW_APPLICATIONS", "MANAGE_RECRUITMENT_PROCESS_APPLICATIONS", "VIEW_MEMBER_DETAILED_INFO"]) &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['customRoles'])
                      ) ||

                      // Case 3: Member management actions (kick, role/status/notes change)
                      // These often involve changing the 'roles' map or 'memberIds'/'memberCount'.
                      // This section needs careful crafting to ensure only authorized changes to the 'roles' map.
                      (
                        (hasPermission(resource.data, "MANAGE_MEMBERS_KICK") &&
                          (request.resource.data.memberIds.size() < resource.data.memberIds.size() || request.resource.data.memberCount < resource.data.memberCount) && // Member removed
                          request.resource.data.diff(resource.data).affectedKeys().hasAny(['memberIds', 'memberCount', 'roles'])
                        ) ||
                        ( (hasPermission(resource.data, "MANAGE_MEMBERS_EDIT_ROLE") || hasPermission(resource.data, "MANAGE_MEMBERS_EDIT_STATUS") || hasPermission(resource.data, "MANAGE_MEMBERS_EDIT_NOTES") ) &&
                          request.resource.data.roles != resource.data.roles && // roles map changed
                          // Ensure that if roles are changed, it's by someone with relevant permission, and other critical fields are not changed simultaneously by this rule path.
                          // More specific field validation within the 'roles' map would be ideal here but makes rules very long.
                          request.resource.data.diff(resource.data).affectedKeys().hasAny(['roles'])
                        )
                      ) ||

                      // Case 4: User updating their own character info in the guild's roles map
                      (
                        request.auth.uid in request.resource.data.roles && // User has a role entry in the new data
                        request.auth.uid in resource.data.roles && // User had a role entry in old data
                        request.resource.data.roles[request.auth.uid].diff(resource.data.roles[request.auth.uid]).affectedKeys().hasOnly([
                          'characterNickname', 'gearScore', 'gearScoreScreenshotUrl', 'gearBuildLink', 'skillBuildLink', 'tlRole', 'tlPrimaryWeapon', 'tlSecondaryWeapon'
                        ]) &&
                        // Ensure critical fields are not changed by the user themselves here
                        request.resource.data.roles[request.auth.uid].roleName == resource.data.roles[request.auth.uid].roleName &&
                        request.resource.data.roles[request.auth.uid].status == resource.data.roles[request.auth.uid].status &&
                        request.resource.data.roles[request.auth.uid].dkpBalance == resource.data.roles[request.auth.uid].dkpBalance &&
                        request.resource.data.roles[request.auth.uid].notes == resource.data.roles[request.auth.uid].notes &&
                        // Ensure only this user's entry in roles map is changed by this rule path.
                        request.resource.data.roles.affectedKeys().hasOnly([request.auth.uid]) &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles'])
                      ) ||

                      // Case 5: Guild joining (public, non-TL)
                      (
                        (request.resource.data.isOpen == true || request.resource.data.password == null) && // Public guild
                        request.resource.data.game != "Throne and Liberty" && // Not a TL game for direct join
                        request.resource.data.memberIds.size() == resource.data.memberIds.size() + 1 &&
                        request.resource.data.memberCount == resource.data.memberCount + 1 &&
                        request.resource.data.memberIds.hasAny([request.auth.uid]) && // current user is the one being added
                        !(request.auth.uid in resource.data.memberIds) && // user was not already a member
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberIds', 'memberCount', 'roles']) &&
                        request.resource.data.roles[request.auth.uid].roleName == "Membro" // New member gets "Membro" role
                      )
                    );

      // Delete: Only the guild owner can delete the guild.
      allow delete: if request.auth != null && isOwner(resource.data);

      // --- Subcollections ---

      match /auditLogs/{logId} {
        allow read: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) && hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, "VIEW_AUDIT_LOG");
        allow create: if request.auth != null &&
                         request.resource.data.actorId == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.timestamp == request.time;
        allow update, delete: if false;
      }

      match /applications/{applicationId} {
        allow read: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                       (hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, "MANAGE_RECRUITMENT_VIEW_APPLICATIONS") || resource.data.applicantId == request.auth.uid);
        allow create: if request.auth != null &&
                         request.resource.data.applicantId == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.status == "pending" &&
                         request.resource.data.submittedAt == request.time;
        allow update: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                         hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, "MANAGE_RECRUITMENT_PROCESS_APPLICATIONS") &&
                         request.resource.data.status != resource.data.status &&
                         request.resource.data.reviewedBy == request.auth.uid &&
                         request.resource.data.reviewedAt == request.time &&
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'reviewedBy', 'reviewedAt']);
        allow delete: if false;
      }

      match /events/{eventId} {
        allow read: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
        allow create: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                         hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, "MANAGE_EVENTS_CREATE") &&
                         request.resource.data.organizerId == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.createdAt == request.time;
        allow update: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                       (
                         (hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, "MANAGE_EVENTS_EDIT") || resource.data.organizerId == request.auth.uid) ||
                         // DKP Redemption logic (member updates their own presence in attendeesWithPin)
                         (
                           request.resource.data.attendeesWithPin.size() == resource.data.attendeesWithPin.size() + 1 && // Only adding
                           request.resource.data.attendeesWithPin.hasAll(resource.data.attendeesWithPin) && // Old values must be present
                           request.resource.data.attendeesWithPin.hasAny([request.auth.uid]) && // Current user is the one added
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendeesWithPin']) && // Only this field changes
                           resource.data.requiresPin == true && resource.data.pinCode != null // Event requires PIN
                         )
                       );
        allow delete: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                         (hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, "MANAGE_EVENTS_DELETE") || resource.data.organizerId == request.auth.uid);
      }

      match /groups/{groupId} {
        allow read: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
        allow create: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                         hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, "MANAGE_GROUPS_CREATE") &&
                         request.resource.data.createdBy == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.createdAt == request.time;
        allow update: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                         hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, "MANAGE_GROUPS_EDIT");
        allow delete: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                         hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, "MANAGE_GROUPS_DELETE");
      }

      match /notifications/{notificationId} {
        allow read: if request.auth != null && isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
        allow create: if request.auth != null &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.timestamp == request.time;
        allow update, delete: if false;
      }

      match /dkpDecayLogs/{logId} {
        allow read: if request.auth != null && isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data);
        allow create: if request.auth != null && isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                          request.resource.data.triggeredByUserId == request.auth.uid &&
                          request.resource.data.guildId == guildId &&
                          request.resource.data.timestamp == request.time;
        allow update, delete: if false;
      }
    }

    match /users/{userId} {
      allow read, update: if request.auth != null && request.auth.uid == userId &&
                         !(request.resource.data.uid != resource.data.uid) &&  // Cannot change uid
                         !(request.resource.data.createdAt != resource.data.createdAt); // Cannot change createdAt
      allow create: if request.auth != null && request.auth.uid == userId;
      allow delete: if false;
    }
  }
}

    
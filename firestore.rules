
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isLoggedIn() {
      return request.auth != null && request.auth.uid != null;
    }

    function getUserDoc(userId) {
      return get(/databases/$(database)/documents/users/$(userId));
    }

    function getGuildDoc(guildId) {
      return get(/databases/$(database)/documents/guilds/$(guildId));
    }

    function isGuildOwner(guildId) {
      let guildData = getGuildDoc(guildId).data;
      return isLoggedIn() && guildData.ownerId == request.auth.uid;
    }

    function isUserRoleInGuild(userId, guildId, targetRole) {
      let guildData = getGuildDoc(guildId).data;
      return isLoggedIn() &&
             guildData.roles != null &&
             guildData.roles[userId] != null &&
             guildData.roles[userId] is map &&
             guildData.roles[userId].generalRole == targetRole;
    }
    
    function isUserAnyRoleInGuild(userId, guildId, targetRolesList) {
      let guildData = getGuildDoc(guildId).data;
      return isLoggedIn() &&
             guildData.roles != null &&
             guildData.roles[userId] != null &&
             guildData.roles[userId] is map &&
             guildData.roles[userId].generalRole in targetRolesList;
    }

    function isGuildLeader(guildId) {
      return isUserRoleInGuild(request.auth.uid, guildId, 'Líder');
    }

    function isGuildLeaderOrViceLeader(guildId) {
      return isUserAnyRoleInGuild(request.auth.uid, guildId, ['Líder', 'Vice-Líder']);
    }

    function isGuildMember(guildId) {
      let guildData = getGuildDoc(guildId).data;
      return isLoggedIn() && guildData.memberIds.hasAny([request.auth.uid]);
    }

    function isGuildPublic(guildId) {
      return getGuildDoc(guildId).data.isOpen == true;
    }

    // User Profiles
    match /users/{userId} {
      allow read: if isLoggedIn(); // Or request.auth.uid == userId for self-read only

      allow create: if request.auth.uid == userId &&
                       request.resource.data.uid == userId &&
                       request.resource.data.email == request.auth.token.email &&
                       request.resource.data.displayName is string &&
                       request.resource.data.displayName.size() > 0 &&
                       request.resource.data.createdAt == request.time &&
                       (!('photoURL' in request.resource.data) || request.resource.data.photoURL is string || request.resource.data.photoURL == null) &&
                       request.resource.data.guilds is list && request.resource.data.guilds.size() == 0 &&
                       request.resource.data.lastNotificationsCheckedTimestamp is map && request.resource.data.lastNotificationsCheckedTimestamp.keys().size() == 0;

      allow update: if request.auth.uid == userId &&
                       request.resource.data.uid == userId && // Cannot change UID
                       request.resource.data.email == resource.data.email && // Cannot change email
                       request.resource.data.createdAt == resource.data.createdAt && // Cannot change creation timestamp
                       (!('displayName' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.displayName is string) &&
                       (!('photoURL' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.photoURL is string || request.resource.data.photoURL == null) &&
                       (!('guilds' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.guilds is list) && // Typically managed by guild joins/leaves
                       (!('lastNotificationsCheckedTimestamp' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.lastNotificationsCheckedTimestamp is map);
    }

    // Guilds
    match /guilds/{guildId} {
      allow read: if isLoggedIn(); // Or be more specific: isGuildMember(guildId) || isGuildPublic(guildId)
      allow list: if isLoggedIn(); // For querying the collection

      allow create: if isLoggedIn() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50 &&
                       request.resource.data.memberCount == 1 &&
                       request.resource.data.memberIds is list && request.resource.data.memberIds.size() == 1 && request.resource.data.memberIds[0] == request.auth.uid &&
                       request.resource.data.roles is map && request.resource.data.roles[request.auth.uid] is map && request.resource.data.roles[request.auth.uid].generalRole == 'Líder' &&
                       request.resource.data.game is string && request.resource.data.game.size() > 0 &&
                       request.resource.data.isOpen is bool &&
                       request.resource.data.createdAt == request.time &&
                       request.resource.data.bannerUrl is string &&
                       request.resource.data.logoUrl is string &&
                       // Optional fields check
                       (!('description' in request.resource.data) || request.resource.data.description is string) &&
                       (!('password' in request.resource.data) || request.resource.data.password is string || request.resource.data.password == null) &&
                       (!('socialLinks' in request.resource.data) || request.resource.data.socialLinks is map) &&
                       (!('tags' in request.resource.data) || request.resource.data.tags is list);


      allow update: if (isGuildOwner(guildId) || isGuildLeaderOrViceLeader(guildId)) &&
                       request.resource.data.ownerId == resource.data.ownerId && // Cannot change owner
                       request.resource.data.createdAt == resource.data.createdAt && // Cannot change creation time
                       // Validate mutable fields
                       (!('name' in request.resource.data.diff(resource.data).affectedKeys()) || (request.resource.data.name is string && request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50)) &&
                       (!('description' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.description is string) &&
                       (!('bannerUrl' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.bannerUrl is string) &&
                       (!('logoUrl' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.logoUrl is string) &&
                       (!('game' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.game is string) &&
                       (!('tags' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.tags is list) &&
                       (!('password' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.password is string || request.resource.data.password == null) &&
                       (!('isOpen' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.isOpen is bool) &&
                       (!('socialLinks' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.socialLinks is map) &&
                       // Member management related updates need specific checks (memberCount, memberIds, roles)
                       // For roles update (e.g. DKP or role change):
                       // This is a simplified rule; more granular control would be better
                       (!('roles' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.roles is map) &&
                       (!('memberIds' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.memberIds is list) &&
                       (!('memberCount' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.memberCount is number);

      allow delete: if isGuildOwner(guildId);

      // Subcollection: Events
      match /events/{eventId} {
        allow read: if isGuildMember(guildId);
        allow create: if isGuildLeaderOrViceLeader(guildId) &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.title is string && request.resource.data.title.size() > 0 &&
                         request.resource.data.date is string && // YYYY-MM-DD
                         request.resource.data.time is string && // HH:mm
                         request.resource.data.organizerId == request.auth.uid &&
                         request.resource.data.createdAt == request.time &&
                         request.resource.data.requiresPin is bool &&
                         // Optional fields
                         (!('description' in request.resource.data) || request.resource.data.description is string) &&
                         (!('endDate' in request.resource.data) || request.resource.data.endDate is string) &&
                         (!('endTime' in request.resource.data) || request.resource.data.endTime is string) &&
                         (!('location' in request.resource.data) || request.resource.data.location is string) &&
                         (!('attendeeIds' in request.resource.data) || request.resource.data.attendeeIds is list) &&
                         (!('dkpValue' in request.resource.data) || request.resource.data.dkpValue is number) &&
                         (!('pinCode' in request.resource.data) || (request.resource.data.requiresPin == true && request.resource.data.pinCode is string && request.resource.data.pinCode.size() == 6)) &&
                         (!('attendeesWithPin' in request.resource.data) || request.resource.data.attendeesWithPin is list) &&
                         (!('category' in request.resource.data) || request.resource.data.category is string) &&
                         (!('subCategory' in request.resource.data) || request.resource.data.subCategory is string);

        allow update: if (isGuildLeaderOrViceLeader(guildId) || // Leaders/VPs can update most fields
                         // Members can update attendeesWithPin to add themselves (PIN check is client-side)
                         (isGuildMember(guildId) &&
                          request.resource.data.attendeesWithPin == resource.data.attendeesWithPin.concat([request.auth.uid]) &&
                          !resource.data.attendeesWithPin.hasAny([request.auth.uid]) &&
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendeesWithPin'])
                         )) &&
                         // Immutable fields
                         request.resource.data.guildId == resource.data.guildId &&
                         request.resource.data.organizerId == resource.data.organizerId &&
                         request.resource.data.createdAt == resource.data.createdAt;

        allow delete: if isGuildLeaderOrViceLeader(guildId);
      }

      // Subcollection: Applications
      match /applications/{applicationId} {
        allow read: if isGuildLeaderOrViceLeader(guildId) || request.auth.uid == resource.data.applicantId;
        allow create: if isLoggedIn() &&
                         request.auth.uid == request.resource.data.applicantId &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.applicantName is string && request.resource.data.applicantName.size() > 0 &&
                         request.resource.data.applicantDisplayName is string &&
                         request.resource.data.gearScore is number && request.resource.data.gearScore >= 0 &&
                         request.resource.data.gearScoreScreenshotUrl is string && request.resource.data.gearScoreScreenshotUrl.size() > 10 && // Basic URL check
                         request.resource.data.discordNick is string && request.resource.data.discordNick.size() > 0 &&
                         request.resource.data.status == 'pending' && // Initial status must be pending
                         request.resource.data.submittedAt == request.time &&
                         // TL Specific fields (optional if not TL guild)
                         (!('tlRole' in request.resource.data) || request.resource.data.tlRole is string) &&
                         (!('tlPrimaryWeapon' in request.resource.data) || request.resource.data.tlPrimaryWeapon is string) &&
                         (!('tlSecondaryWeapon' in request.resource.data) || request.resource.data.tlSecondaryWeapon is string);


        allow update: if isGuildLeaderOrViceLeader(guildId) &&
                         // Only status, reviewedBy, reviewedAt can be changed by leader/vice
                         request.resource.data.status in ['approved', 'rejected', 'auto_approved'] &&
                         request.resource.data.reviewedBy == request.auth.uid &&
                         request.resource.data.reviewedAt == request.time &&
                         // Immutable fields
                         request.resource.data.guildId == resource.data.guildId &&
                         request.resource.data.applicantId == resource.data.applicantId &&
                         request.resource.data.submittedAt == resource.data.submittedAt;
        allow delete: if false; // Generally, applications shouldn't be deleted, just status changed
      }

      // Subcollection: Audit Logs
      match /auditLogs/{logId} {
        allow read: if isGuildLeaderOrViceLeader(guildId);
        allow create: if (isLoggedIn() && request.auth.uid == request.resource.data.actorId) && // Actor must be the one creating the log
                         request.resource.data.timestamp == request.time &&
                         request.resource.data.actorId is string &&
                         request.resource.data.action is string &&
                         request.resource.data.details is map;
        allow update, delete: if false; // Audit logs should be immutable
      }
      
      // Subcollection: Notifications
      match /notifications/{notificationId} {
          allow read: if isGuildMember(guildId); // All guild members can read notifications for their guild
          allow create: if isGuildLeaderOrViceLeader(guildId) && // Only leaders/vices can create notifications
                           request.resource.data.guildId == guildId &&
                           request.resource.data.message is string && request.resource.data.message.size() > 0 &&
                           request.resource.data.type is string &&
                           request.resource.data.link is string &&
                           request.resource.data.timestamp == request.time &&
                           (!('details' in request.resource.data) || request.resource.data.details is map) &&
                           (!('createdByUserId' in request.resource.data) || request.resource.data.createdByUserId == request.auth.uid) &&
                           (!('targetUserId' in request.resource.data) || request.resource.data.targetUserId is string) &&
                           (!('isRead' in request.resource.data) || request.resource.data.isRead == false); // New notifications are unread
          
          // Users can mark their own notifications as read (if 'isRead' is a field per user, this rule needs adjustment)
          // For a simple 'isRead' on the notification itself (seen by anyone), this could be:
          allow update: if isGuildMember(guildId) && 
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']) &&
                           request.resource.data.isRead == true; // Can only mark as read
                           
          allow delete: if false; // Or isGuildLeaderOrViceLeader(guildId) if deletion is needed
      }
    }
  }
}

    
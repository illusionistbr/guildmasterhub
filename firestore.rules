
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(guildDocData) {
      return isAuthenticated() && request.auth.uid == guildDocData.ownerId;
    }

    function isGuildMember(guildDocData) {
      // Ensure memberIds exists and is a list before using hasAny
      return isAuthenticated() &&
             typeof guildDocData.memberIds == 'list' && // Check if memberIds is a list
             guildDocData.memberIds.hasAny([request.auth.uid]);
    }

    function hasGuildPermission(guildDocData, permission) {
      let userRoleName = guildDocData.roles[request.auth.uid].roleName;
      return isAuthenticated() &&
             isGuildMember(guildDocData) &&
             request.auth.uid in guildDocData.roles && // User has a role entry
             userRoleName in guildDocData.customRoles && // The role exists in customRoles
             guildDocData.customRoles[userRoleName].permissions.hasAny([permission]); // The role has the specific permission
    }

    // User profiles
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == userId;
      // Allow users to update their own displayName, photoURL, and notification timestamps
      allow update: if isAuthenticated() && request.auth.uid == userId &&
                       request.resource.data.keys().hasOnly(['displayName', 'photoURL', 'lastNotificationsCheckedTimestamp', 'guilds', 'email', 'uid', 'createdAt']);
    }

    // Guilds
    match /guilds/{guildId} {
      allow read: if isAuthenticated(); // Allow any authenticated user to read guild data (e.g., for guild list)
                     // Consider if isGuildMember(resource.data) is better for more privacy.

      allow create: if isAuthenticated() &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.name != null && // Ensure basic fields
                       request.resource.data.game != null;

      allow update: if isAuthenticated() && (
        // Case 1: Owner can update most guild settings.
        (isOwner(resource.data) &&
            !('ownerId' in request.resource.data.diff(resource.data).affectedKeys()) && // Owner cannot change ownerId
            !('memberCount' in request.resource.data.diff(resource.data).affectedKeys()) && // memberCount managed by specific actions
            !('createdAt' in request.resource.data.diff(resource.data).affectedKeys()) // createdAt is immutable
        ) ||
        // Case 2: User with MANAGE_GUILD_SETTINGS_GENERAL permission
        (hasGuildPermission(resource.data, 'MANAGE_GUILD_SETTINGS_GENERAL') &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['name', 'description', 'password', 'isOpen', 'socialLinks', 'game', 'region', 'server', 'tags'])
        ) ||
        // Case 3: User with MANAGE_GUILD_SETTINGS_APPEARANCE permission
        (hasGuildPermission(resource.data, 'MANAGE_GUILD_SETTINGS_APPEARANCE') &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['bannerUrl', 'logoUrl'])
        ) ||
        // Case 4: User with MANAGE_ROLES_PERMISSIONS permission
        (hasGuildPermission(resource.data, 'MANAGE_ROLES_PERMISSIONS') &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['customRoles'])
        ) ||
        // Case 5: Member updating *their own* specific profile fields within the guild's 'roles' map.
        (isGuildMember(resource.data) &&
            request.auth.uid in request.resource.data.roles && // Ensure their role entry is part of the update
            request.resource.data.roles[request.auth.uid].keys().hasOnly(
                resource.data.roles[request.auth.uid].keys().concat( // Allow existing keys plus these specific ones
                    ['characterNickname', 'gearScore', 'gearScoreScreenshotUrl', 'gearBuildLink', 'skillBuildLink', 'tlRole', 'tlPrimaryWeapon', 'tlSecondaryWeapon']
                ).removeAll(['roleName', 'dkpBalance', 'status', 'notes']) // Explicitly disallow changing these critical fields by self
            ) &&
            request.resource.data.roles[request.auth.uid].roleName == resource.data.roles[request.auth.uid].roleName && // Cannot change own roleName
            request.resource.data.roles[request.auth.uid].dkpBalance == resource.data.roles[request.auth.uid].dkpBalance && // Cannot change own DKP
            request.resource.data.roles[request.auth.uid].status == resource.data.roles[request.auth.uid].status && // Cannot change own status
            request.resource.data.roles[request.auth.uid].notes == resource.data.roles[request.auth.uid].notes && // Cannot change own notes
            // Ensure only the user's own role entry is being modified in the 'roles' map, unless other map keys also change (owner case)
            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']) || isOwner(resource.data)) &&
            // If 'roles' is the only top-level key changing, ensure only the user's own role sub-document is changing.
            (!(request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles'])) ||
             request.resource.data.roles.diff(resource.data.roles).affectedKeys().hasOnly([request.auth.uid])
            )
        ) ||
        // Case 6: User with permissions to manage other members' roles (roleName, status, notes).
        // This is simplified. Ideally, Cloud Functions for such critical cross-user updates.
        (
          ( hasGuildPermission(resource.data, 'MANAGE_MEMBERS_EDIT_ROLE') ||
            hasGuildPermission(resource.data, 'MANAGE_MEMBERS_EDIT_STATUS') ||
            hasGuildPermission(resource.data, 'MANAGE_MEMBERS_EDIT_NOTES')
          ) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']) &&
          // Ensure only the roleName, status, or notes fields within specific member roles are changing
          // This part is hard to write perfectly without listing all possible affected member IDs
          // and checking their sub-fields. This rule is thus a bit permissive if 'roles' is the only key.
          true // Placeholder for more complex validation if needed, or rely on Cloud Functions
        ) ||
        // Case 7: Adding/removing members (e.g., application accept, kick, public join)
        (
          (
            hasGuildPermission(resource.data, 'MANAGE_RECRUITMENT_PROCESS_APPLICATIONS') ||
            hasGuildPermission(resource.data, 'MANAGE_MEMBERS_KICK') ||
            request.resource.data.isOpen == true // For public guilds allowing direct join
          ) &&
          request.resource.data.diff(resource.data).affectedKeys().hasAny(['memberIds', 'memberCount', 'roles'])
        )
      );

      allow delete: if isAuthenticated() && isOwner(resource.data); // Only owner can delete
    }

    // Applications subcollection
    match /guilds/{guildId}/applications/{applicationId} {
      allow read: if isAuthenticated() && (
        request.auth.uid == resource.data.applicantId ||
        isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_RECRUITMENT_VIEW_APPLICATIONS')
      );
      allow create: if isAuthenticated() &&
                       request.resource.data.applicantId == request.auth.uid &&
                       request.resource.data.guildId == guildId &&
                       request.resource.data.status == 'pending'; // Ensure initial status
      allow update: if isAuthenticated() &&
                       (isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
                        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_RECRUITMENT_PROCESS_APPLICATIONS')) &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'reviewedBy', 'reviewedAt']);
      allow delete: if false; // Applications are generally not deleted
    }

    // Events subcollection
    match /guilds/{guildId}/events/{eventId} {
      allow read: if isAuthenticated() && isGuildMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
      allow create: if isAuthenticated() &&
                       (isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
                        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_EVENTS_CREATE')) &&
                       request.resource.data.organizerId == request.auth.uid &&
                       request.resource.data.guildId == guildId;
      allow update: if isAuthenticated() && (
        (isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
         hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_EVENTS_EDIT')) ||
        (request.auth.uid == resource.data.organizerId && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['title', 'description', 'date', 'time', 'endDate', 'endTime', 'location', 'category', 'subCategory', 'dkpValue', 'requiresPin', 'pinCode'])) ||
        (isGuildMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendeesWithPin'])) // Members updating PIN attendance
      );
      allow delete: if isAuthenticated() && (
        isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_EVENTS_DELETE') ||
        (request.auth.uid == resource.data.organizerId) // Organizer can delete own event
      );
    }

    // Audit Logs subcollection
    match /guilds/{guildId}/auditLogs/{logId} {
      allow read: if isAuthenticated() && (
        isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'VIEW_AUDIT_LOG')
      );
      allow create: if isAuthenticated() &&
                       request.resource.data.actorId == request.auth.uid &&
                       (isGuildMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) || isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data)) &&
                       !('timestamp' in request.resource.data.diff(resource.data).affectedKeys()); // Timestamp should be server-generated
      allow update, delete: if false;
    }

    // Groups subcollection
    match /guilds/{guildId}/groups/{groupId} {
      allow read: if isAuthenticated() && isGuildMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
      allow create: if isAuthenticated() &&
                       (isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
                        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_GROUPS_CREATE')) &&
                       request.resource.data.createdBy == request.auth.uid &&
                       request.resource.data.guildId == guildId;
      allow update: if isAuthenticated() &&
                       (isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
                        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_GROUPS_EDIT'));
      allow delete: if isAuthenticated() &&
                       (isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
                        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_GROUPS_DELETE'));
    }

    // Notifications subcollection
    match /guilds/{guildId}/notifications/{notificationId} {
      allow read: if isAuthenticated() && isGuildMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
      allow create: if isAuthenticated() &&
                       (isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
                        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_EVENTS_CREATE')) && // Example: allow event creators to create notifications
                       request.resource.data.createdByUserId == request.auth.uid &&
                       request.resource.data.guildId == guildId &&
                       !('timestamp' in request.resource.data.diff(resource.data).affectedKeys());
      allow update, delete: if false;
    }
    
    // DKP Decay Logs subcollection
    match /guilds/{guildId}/dkpDecayLogs/{logId} {
      allow read: if isAuthenticated() && (
        isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
        hasGuildPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'VIEW_AUDIT_LOG') // Re-use VIEW_AUDIT_LOG for simplicity
      );
      allow create: if isAuthenticated() &&
                       isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                       request.resource.data.triggeredByUserId == request.auth.uid &&
                       !('timestamp' in request.resource.data.diff(resource.data).affectedKeys());
      allow update, delete: if false;
    }
  }
}

    

rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isOwner(guildDoc) {
      return request.auth != null && request.auth.uid == guildDoc.ownerId;
    }

    function isMember(guildDoc) {
      // Ensure memberIds exists and is a list before calling hasAny
      return request.auth != null && 
             'memberIds' in guildDoc && 
             guildDoc.memberIds != null && 
             guildDoc.memberIds.hasAny([request.auth.uid]);
    }

    // Checks if the currently authenticated user has a specific permission in the given guildDoc
    function hasPermission(guildDoc, permission) {
      // Ensure roles and customRoles paths exist before trying to access them
      return request.auth != null &&
             'roles' in guildDoc && request.auth.uid in guildDoc.roles &&
             guildDoc.roles[request.auth.uid].roleName != null && // roleName itself exists
             'customRoles' in guildDoc && guildDoc.roles[request.auth.uid].roleName in guildDoc.customRoles &&
             guildDoc.customRoles[guildDoc.roles[request.auth.uid].roleName].permissions != null && // permissions list exists
             guildDoc.customRoles[guildDoc.roles[request.auth.uid].roleName].permissions.hasAny([permission]);
    }

    // Checks if a user is trying to update only their own allowed profile fields within the roles map
    function isSelfProfileUpdate(newRoleData, oldRoleData) {
      let modifiableBySelf = [
        'characterNickname', 'gearScore', 'gearScoreScreenshotUrl',
        'gearBuildLink', 'skillBuildLink', 'tlRole',
        'tlPrimaryWeapon', 'tlSecondaryWeapon'
      ];
      let adminOnlyFields = ['roleName', 'status', 'notes', 'dkpBalance'];

      let adminFieldIsAttemptedChange = adminOnlyFields.filter(field => newRoleData[field] != oldRoleData[field]).size() > 0;
      if (adminFieldIsAttemptedChange) {
        return false;
      }

      let modifiableFieldIsChanged = modifiableBySelf.filter(field => newRoleData[field] != oldRoleData[field]).size() > 0;
      if (!modifiableFieldIsChanged) {
        // If nothing allowed is changed, this specific self-update rule part isn't met.
        // This also handles the case where no fields changed at all.
        return false; 
      }
      
      let allChangedKeysInRole = newRoleData.diff(oldRoleData).affectedKeys();
      // Ensure all keys that *did* change are within the 'modifiableBySelf' list.
      // The filter constructs the list of keys from `modifiableBySelf` that were actually affected.
      // `hasOnly` then checks if `allChangedKeysInRole` is exactly that set.
      return allChangedKeysInRole.hasOnly(
        modifiableBySelf.filter(key => allChangedKeysInRole.hasAny([key]))
      );
    }
    
    // User collection
    match /users/{userId} {
      allow read: if request.auth != null;
      allow create: if request.auth.uid == userId && 
                       request.resource.data.uid == userId && // Ensure uid is set correctly
                       request.resource.data.email == request.auth.token.email && // Ensure email matches auth
                       !("createdAt" in resource.data); // createdAt only on create
      allow update: if request.auth.uid == userId &&
                       request.resource.data.uid == resource.data.uid && // UID cannot change
                       request.resource.data.email == resource.data.email && // Email cannot change (usually)
                       !("createdAt" in request.resource.data); // createdAt cannot be updated
    }

    // Guilds collection
    match /guilds/{guildId} {
      allow read: if isMember(resource.data);
      allow create: if request.auth.uid == request.resource.data.ownerId &&
                       !("createdAt" in resource.data); // Ensure createdAt is server-side

      allow update: if request.auth != null && (
        // Case 1: Owner is making changes.
        (isOwner(request.resource.data) && (
            // Sub-case 1.1: Owner changing top-level config (NOT roles or customRoles map itself)
            (
              // Check that *only* allowed top-level fields are being modified.
              request.resource.data.diff(resource.data).affectedKeys()
                .hasOnly([
                    'name', 'description', 'password', 'isOpen', 'bannerUrl', 'logoUrl', 'socialLinks', 'game', 'region', 'server', 'tags', 'recruitmentQuestions',
                    'dkpSystemEnabled', 'dkpRedemptionWindow', 'dkpDefaultsPerCategory',
                    'dkpDecayEnabled', 'dkpDecayPercentage', 'dkpDecayIntervalDays', 'dkpDecayInitialDate'
                ].filter(key => // Filter for keys that were actually added, changed, or removed
                    (request.resource.data[key] != resource.data[key]) || // Covers value changes and additions where old value was undefined
                    (key in resource.data && !(key in request.resource.data)) ||    // Field deleted
                    (!(key in resource.data) && (key in request.resource.data))     // Field added (and not present in old)
                )) &&
             request.resource.data.diff(resource.data).affectedKeys().size() > 0 // At least one of these fields changed
            ) ||
            // Sub-case 1.2: Owner changing something within the 'roles' map (e.g., DKP decay, manual role edits)
            (
              request.resource.data.roles != resource.data.roles &&
              request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles'])
            )
          )
        ) ||
        // Case 2: User with MANAGE_ROLES_PERMISSIONS updating customRoles (and nothing else)
        (hasPermission(request.resource.data, 'MANAGE_ROLES_PERMISSIONS') &&
          request.resource.data.customRoles != resource.data.customRoles &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['customRoles'])
        ) ||
        // Case 3: Member self-updating their own allowed profile fields in their roles entry (and nothing else at top level)
        (
          isMember(request.resource.data) && request.auth.uid in request.resource.data.roles && // Member and has a role entry
          resource.data.roles[request.auth.uid] != null && // Old role data must exist for comparison
          request.resource.data.roles[request.auth.uid] != resource.data.roles[request.auth.uid] && // Their own role data actually changed
          isSelfProfileUpdate(request.resource.data.roles[request.auth.uid], resource.data.roles[request.auth.uid]) && // The change consists of allowed fields
          // Ensure that only their specific part of the roles map changed, or if other top-level fields change, another rule must permit it.
          // This checks if the *only* top-level key affected is 'roles', and within 'roles', only their entry changed.
          (
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']) &&
            request.resource.data.roles.diff(resource.data.roles).affectedKeys().hasOnly([request.auth.uid])
          )
        )
      );

      allow delete: if isOwner(resource.data);

      // Subcollections
      match /auditLogs/{logId} {
        allow read: if isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                       hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'VIEW_AUDIT_LOG');
        allow create: if request.auth.uid == request.resource.data.actorId &&
                         isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                         !("timestamp" in resource.data); // Ensure timestamp is server-generated
        allow update, delete: if false;
      }

      match /applications/{applicationId} {
        allow read: if hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_RECRUITMENT_VIEW_APPLICATIONS');
        allow create: if request.auth.uid == request.resource.data.applicantId &&
                         !("submittedAt" in resource.data); // Ensure submittedAt is server-generated
        allow update: if hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_RECRUITMENT_PROCESS_APPLICATIONS') &&
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'reviewedBy', 'reviewedAt']) &&
                         !("submittedAt" in request.resource.data); // submittedAt should not change
        allow delete: if hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_RECRUITMENT_PROCESS_APPLICATIONS');
      }

      match /events/{eventId} {
        allow read: if isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
        allow create: if hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_EVENTS_CREATE') &&
                         !("createdAt" in resource.data);
        allow update: if (
                        hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_EVENTS_EDIT') &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                          'title', 'description', 'date', 'time', 'endDate', 'endTime', 'location', 'dkpValue', 'requiresPin', 'category', 'subCategory'
                        ].filter(key => // Filter for keys that actually changed
                            (request.resource.data[key] != resource.data[key]) ||
                            (key in resource.data && !(key in request.resource.data)) ||
                            (!(key in resource.data) && (key in request.resource.data))
                        )) && request.resource.data.diff(resource.data).affectedKeys().size() > 0 && // Ensure at least one field changed
                        !("createdAt" in request.resource.data) // createdAt cannot be changed
                       ) ||
                       ( // Allow any member to update attendeesWithPin (e.g., when submitting a PIN)
                         isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) &&
                         request.resource.data.attendeesWithPin != resource.data.attendeesWithPin &&
                         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendeesWithPin']) &&
                         !("createdAt" in request.resource.data) // createdAt cannot be changed
                       );
        allow delete: if hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_EVENTS_DELETE');
      }

      match /groups/{groupId} {
        allow read: if isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
        allow create: if hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_GROUPS_CREATE') &&
                         !("createdAt" in resource.data);
        allow update: if hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_GROUPS_EDIT') &&
                         !("createdAt" in request.resource.data);
        allow delete: if hasPermission(get(/databases/$(database)/documents/guilds/$(guildId)).data, 'MANAGE_GROUPS_DELETE');
      }
      
      match /notifications/{notificationId} {
        allow read: if isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data);
        allow create: if (isOwner(get(/databases/$(database)/documents/guilds/$(guildId)).data) ||
                         (isMember(get(/databases/$(database)/documents/guilds/$(guildId)).data) && request.auth.uid == request.resource.data.createdByUserId)) &&
                         !("timestamp" in resource.data);
        allow update, delete: if false;
      }
    }
  }
}

    
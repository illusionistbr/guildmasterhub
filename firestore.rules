
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Get data for a specific guild
    function getGuildData(guildId) {
      return get(/databases/$(database)/documents/guilds/$(guildId)).data;
    }

    // Get the role of a user in a specific guild
    function getUserRoleInGuild(userId, guildId) {
      let guildData = getGuildData(guildId);
      return guildData.roles[userId];
    }

    function isValidGuildRole(role) {
      return role == "Líder" || role == "Vice-Líder" || role == "Conselheiro" || role == "Oficial" || role == "Membro";
    }
    
    function countRole(rolesMap, roleName) {
      return rolesMap.keys().filter(uid => rolesMap[uid] == roleName).size();
    }

    match /users/{userId} {
      allow read: if true; // Publicly readable for avatars/displayNames
      allow create: if isUser(userId) && 
                      request.resource.data.uid == userId &&
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.keys().hasAll(['uid', 'email', 'displayName', 'photoURL', 'createdAt']) &&
                      request.resource.data.createdAt == request.time;
      allow update: if isUser(userId) &&
                      request.resource.data.uid == userId && // Cannot change UID
                      request.resource.data.email == resource.data.email && // Cannot change email via profile update
                      (!request.resource.data.keys().hasAny(['createdAt']) || request.resource.data.createdAt == resource.data.createdAt); // createdAt immutable if present
      allow delete: if false; // Users cannot delete their own profiles for now
    }

    match /guilds/{guildId} {
      allow read: if true; // Guilds are publicly readable for listing/browsing

      function commonValidations(guildData, upcomingData) {
        return upcomingData.name.size() >= 3 && upcomingData.name.size() <= 50 &&
               (!upcomingData.keys().has('description') || upcomingData.description.size() <= 500) &&
               (!upcomingData.keys().has('game') || upcomingData.game.size() <= 50) &&
               (!upcomingData.keys().has('password') || upcomingData.password.size() <= 50) &&
               upcomingData.ownerId == request.auth.uid && // For create, or new ownerId must be leader
               upcomingData.memberIds.hasAny([upcomingData.ownerId]) &&
               upcomingData.memberCount == upcomingData.memberIds.size() &&
               upcomingData.roles[upcomingData.ownerId] == "Líder" &&
               countRole(upcomingData.roles, "Líder") == 1 &&
               upcomingData.roles.keys().hasAll(upcomingData.memberIds) && // All members must have a role
               upcomingData.memberIds.hasAll(upcomingData.roles.keys()) && // All roles must correspond to a member
               upcomingData.roles.values().filter(role => !isValidGuildRole(role)).size() == 0; // All roles must be valid
      }
      
      function isOwnerOrLeader(guildData) {
          return request.auth.uid == guildData.ownerId || getUserRoleInGuild(request.auth.uid, guildId) == "Líder";
      }
      
      function isViceLeader(guildData) {
          return getUserRoleInGuild(request.auth.uid, guildId) == "Vice-Líder";
      }

      allow create: if isSignedIn() &&
                      commonValidations(null, request.resource.data) &&
                      request.resource.data.ownerId == request.auth.uid &&
                      request.resource.data.memberIds.size() == 1 &&
                      request.resource.data.memberIds[0] == request.auth.uid &&
                      request.resource.data.memberCount == 1 &&
                      request.resource.data.roles[request.auth.uid] == "Líder" &&
                      request.resource.data.createdAt == request.time;
      
      allow update: if isSignedIn() &&
                      commonValidations(resource.data, request.resource.data) &&
                      (
                        // Case 1: Guild owner/leader or vice-leader updating basic info, banner, logo, or managing roles/members
                        (isOwnerOrLeader(resource.data) || isViceLeader(resource.data)) &&
                        (
                           // Only owner/leader can change ownerId (transfer leadership)
                           (request.resource.data.ownerId == resource.data.ownerId || isOwnerOrLeader(resource.data)) &&
                           // Name, description, game, password, isOpen, socialLinks can be changed by L/VL
                           (request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                             'name', 'description', 'game', 'password', 'isOpen', 'socialLinks', 
                             'bannerUrl', 'logoUrl', 
                             'memberIds', 'memberCount', 'roles', 'ownerId' // ownerId only if leader transfer
                           ])) &&
                           // Specific check for roles management based on hierarchy
                           (
                            !request.resource.data.keys().has('roles') || // If roles are not being changed, allow
                            (
                              // Leader changing roles
                              isOwnerOrLeader(resource.data) &&
                              (
                                // Leader cannot demote self or make another leader via simple roles update
                                (request.resource.data.roles[request.auth.uid] == "Líder" || request.resource.data.roles[request.auth.uid] == resource.data.roles[request.auth.uid]) && 
                                countRole(request.resource.data.roles, "Líder") == 1
                              )
                            ) ||
                            (
                              // Vice-Leader changing roles
                              isViceLeader(resource.data) &&
                              request.resource.data.roles.keys().filter(
                                userIdToChange => 
                                  // VL cannot change Leader or other VLs
                                  (resource.data.roles[userIdToChange] == "Líder" || resource.data.roles[userIdToChange] == "Vice-Líder") &&
                                  request.resource.data.roles[userIdToChange] != resource.data.roles[userIdToChange]
                              ).size() == 0 &&
                              // VL cannot promote to Leader or Vice-Leader
                              request.resource.data.roles.values().filter(
                                roleVal => roleVal == "Líder" || roleVal == "Vice-Líder"
                              ).size() <= countRole(resource.data.roles, "Líder") + countRole(resource.data.roles, "Vice-Líder") 
                            )
                           )
                        )
                        ||
                        // Case 2: User joining an open guild or a password-protected guild they have the password for
                        // This part is simplified; password check ideally happens server-side before client attempts update.
                        // Client would only update memberIds, memberCount, and add their own role as "Membro".
                        (
                          !resource.data.memberIds.hasAny([request.auth.uid]) && // User is not already a member
                          request.resource.data.memberIds.hasAll([request.auth.uid]) && // Adding self to members
                          request.resource.data.memberIds.size() == resource.data.memberIds.size() + 1 &&
                          request.resource.data.memberCount == resource.data.memberCount + 1 &&
                          request.resource.data.roles[request.auth.uid] == "Membro" && // New member gets "Membro" role
                          // Ensure only roles, memberIds, memberCount are changed
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberIds', 'memberCount', 'roles']) &&
                           // Ensure no other roles were changed
                          request.resource.data.roles.keys().filter(k => k != request.auth.uid && request.resource.data.roles[k] != resource.data.roles[k]).size() == 0
                        )
                      );

      allow delete: if isSignedIn() && isOwnerOrLeader(resource.data) && request.auth.uid == resource.data.ownerId;

      // Audit Logs Subcollection
      match /auditLogs/{logId} {
        allow read: if isSignedIn() &&
                      (getUserRoleInGuild(request.auth.uid, guildId) == "Líder" ||
                       getUserRoleInGuild(request.auth.uid, guildId) == "Vice-Líder");
        allow create: if isSignedIn() &&
                        request.resource.data.actorId == request.auth.uid &&
                        getUserRoleInGuild(request.auth.uid, guildId) != null && // Must be a member
                        request.resource.data.timestamp == request.time &&
                        isValidGuildRole(request.resource.data.details.oldValue) && // Validate if present
                        isValidGuildRole(request.resource.data.details.newValue) && // Validate if present
                        isValidGuildRole(request.resource.data.details.kickedUserRole); // Validate if present
        allow update, delete: if false; // Audit logs are immutable
      }
    }
  }
}

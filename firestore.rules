
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user is a member of a guild
    function isGuildMember(guildId, userId) {
      // Path to the specific guild document
      let guildPath = /databases/$(database)/documents/guilds/$(guildId);
      // Check if the guild document exists and if memberIds list contains the userId
      return exists(guildPath) && get(guildPath).data.memberIds.hasAny([userId]);
    }

    // Helper function to get a user's permissions list for a specific guild
    function getRolePermissions(guildId, userId) {
      let guildPath = /databases/$(database)/documents/guilds/$(guildId);
      // Check if the guild document exists
      if (!exists(guildPath)) {
        return [];
      }
      let guildData = get(guildPath).data;
      // Check if roles map, specific user role entry, and roleName exist
      if (!('roles' in guildData) || !(userId in guildData.roles) || !('roleName' in guildData.roles[userId])) {
        return [];
      }
      let userRoleName = guildData.roles[userId].roleName;
      // Check if customRoles map, specific roleName entry, and permissions list exist
      if (!('customRoles' in guildData) || !(userRoleName in guildData.customRoles) || !('permissions' in guildData.customRoles[userRoleName])) {
        return [];
      }
      return guildData.customRoles[userRoleName].permissions;
    }

    // Helper function to check if a user has a specific permission in a guild
    function hasGuildPermission(guildId, userId, permission) {
      return getRolePermissions(guildId, userId).hasAny([permission]);
    }

    // Rules for 'guilds' collection
    match /guilds/{guildId} {
      allow read: if true; // Anyone can read guild basic info for listing/discovery
      allow list: if true; // Allow listing of guilds

      allow create: if request.auth.uid != null &&
                       request.resource.data.ownerId == request.auth.uid &&
                       request.resource.data.memberIds.hasAny([request.auth.uid]) &&
                       request.resource.data.memberCount == 1 &&
                       request.resource.data.name.size() >= 3 && request.resource.data.name.size() <= 50 &&
                       (!request.resource.data.containsKey('password') || request.resource.data.password.size() <= 50) &&
                       // Ensure roles for owner are set up correctly
                       request.resource.data.roles[request.auth.uid].roleName == "Lider" &&
                       request.resource.data.customRoles.Lider.permissions.hasAny(['MANAGE_MEMBERS_VIEW']); // Ensure Lider role has at least one perm

      allow update: if request.auth.uid == resource.data.ownerId || // Owner can update most things
                       (isGuildMember(guildId, request.auth.uid) && (
                         // Updating general guild settings (name, password, etc.)
                         (hasGuildPermission(guildId, request.auth.uid, 'MANAGE_GUILD_SETTINGS_GENERAL') &&
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                             'name', 'description', 'password', 'isOpen', 'game', 'region', 'server', 'socialLinks',
                             'dkpSystemEnabled', 'dkpRedemptionWindow', 'dkpDefaultsPerCategory',
                             'dkpDecayEnabled', 'dkpDecayPercentage', 'dkpDecayIntervalDays', 'dkpDecayInitialDate',
                             'recruitmentQuestions' // Added for recruitment settings
                           ])
                         ) ||
                         // Updating guild appearance (banner, logo)
                         (hasGuildPermission(guildId, request.auth.uid, 'MANAGE_GUILD_SETTINGS_APPEARANCE') &&
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['bannerUrl', 'logoUrl'])
                         ) ||
                         // Updating custom roles and their permissions
                         (hasGuildPermission(guildId, request.auth.uid, 'MANAGE_ROLES_PERMISSIONS') &&
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['customRoles'])
                         ) ||
                         // User updating their own guild-specific profile (characterNickname, gearScore, etc.)
                         (
                           resource.data.roles[request.auth.uid] != null && // User must have an existing role entry
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['roles']) && // Ensures only the 'roles' map is being changed at the guild doc level for this specific update type
                           request.resource.data.roles.keys().toSet().hasOnly(resource.data.roles.keys()) && // No other user's role entries are added/removed by the user themselves
                           request.resource.data.roles[request.auth.uid].diff(resource.data.roles[request.auth.uid]).affectedKeys()
                             .hasOnly(['characterNickname', 'gearScore', 'gearScoreScreenshotUrl', 'gearBuildLink', 'skillBuildLink', 'tlRole', 'tlPrimaryWeapon', 'tlSecondaryWeapon', 'status', 'notes'])
                         ) ||
                         // Admin actions on member roles (kick, role change, status change, note change)
                         (
                           (
                             hasGuildPermission(guildId, request.auth.uid, 'MANAGE_MEMBERS_EDIT_ROLE') ||
                             hasGuildPermission(guildId, request.auth.uid, 'MANAGE_MEMBERS_EDIT_STATUS') ||
                             hasGuildPermission(guildId, request.auth.uid, 'MANAGE_MEMBERS_EDIT_NOTES') ||
                             hasGuildPermission(guildId, request.auth.uid, 'MANAGE_MEMBERS_KICK') // Kick might modify memberIds/memberCount
                           ) &&
                           // These permissions usually modify the 'roles' map, or 'memberIds'/'memberCount' for kicks.
                           // Assuming client-side ensures specific field integrity within roles map for role/status/note changes.
                           request.resource.data.diff(resource.data).affectedKeys().hasAny(['roles', 'memberIds', 'memberCount'])
                         )
                       ));

      allow delete: if request.auth.uid == resource.data.ownerId; // Only guild owner can delete

      // Rules for subcollections of guilds

      // Rules for 'applications' subcollection
      match /applications/{applicationId} {
        allow read: if isGuildMember(guildId, request.auth.uid) &&
                         hasGuildPermission(guildId, request.auth.uid, 'MANAGE_RECRUITMENT_VIEW_APPLICATIONS');

        allow create: if request.auth.uid != null &&
                         request.resource.data.applicantId == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         (request.resource.data.status == 'pending' || request.resource.data.status == 'auto_approved') && // Allow auto_approved for public guilds
                         request.resource.data.keys().hasAll(['applicantName', 'gearScore', 'discordNick', 'submittedAt']) &&
                         // Allow reviewedBy/At for auto_approved scenario
                         (request.resource.data.status == 'auto_approved' ?
                            (request.resource.data.reviewedBy == 'system' && request.resource.data.reviewedAt == request.time) :
                            (!request.resource.data.containsKey('reviewedBy') && !request.resource.data.containsKey('reviewedAt'))
                         );

        allow update: if isGuildMember(guildId, request.auth.uid) &&
                         hasGuildPermission(guildId, request.auth.uid, 'MANAGE_RECRUITMENT_PROCESS_APPLICATIONS') &&
                         request.resource.data.status in ['approved', 'rejected'] && // Can only update to these statuses
                         request.resource.data.reviewedBy == request.auth.uid &&
                         request.resource.data.reviewedAt == request.time &&
                         // Ensure only status, reviewedBy, reviewedAt are changed from a pending state
                         (resource.data.status == 'pending' ?
                            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'reviewedBy', 'reviewedAt']) :
                            true // Allow further updates if already reviewed (though typically not needed)
                         );
        // No delete for applications, treat them as records
        allow delete: if false;
      }

      // Rules for 'auditLogs' subcollection
      match /auditLogs/{logId} {
        allow read: if isGuildMember(guildId, request.auth.uid) &&
                       hasGuildPermission(guildId, request.auth.uid, 'VIEW_AUDIT_LOG');
        allow list: if isGuildMember(guildId, request.auth.uid) &&
                       hasGuildPermission(guildId, request.auth.uid, 'VIEW_AUDIT_LOG');
        allow create: if request.auth.uid != null && isGuildMember(guildId, request.auth.uid) && // Actor must be a guild member
                       request.resource.data.actorId == request.auth.uid &&
                       request.resource.data.timestamp == request.time;
        allow update, delete: if false; // Logs are immutable
      }

      // Rules for 'events' subcollection
      match /events/{eventId} {
        allow read: if isGuildMember(guildId, request.auth.uid); // Any guild member can read events
        allow list: if isGuildMember(guildId, request.auth.uid);

        allow create: if isGuildMember(guildId, request.auth.uid) &&
                         hasGuildPermission(guildId, request.auth.uid, 'MANAGE_EVENTS_CREATE') &&
                         request.resource.data.organizerId == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.createdAt == request.time;

        allow update: if isGuildMember(guildId, request.auth.uid) &&
                         (
                           (hasGuildPermission(guildId, request.auth.uid, 'MANAGE_EVENTS_EDIT') && request.resource.data.organizerId == resource.data.organizerId) || // Original organizer with edit permission
                           request.auth.uid == resource.data.organizerId || // Organizer can always edit their own event
                           hasGuildPermission(guildId, request.auth.uid, 'MANAGE_EVENTS_VIEW_PIN') // Or if user is updating attendeesWithPin (DKP redemption)
                         ) &&
                         // If redeeming DKP, only allow attendeesWithPin and dkpBalance on roles to change.
                         (request.resource.data.containsKey('attendeesWithPin') ?
                            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendeesWithPin']) :
                            true // Otherwise, allow other fields to be updated by organizer/editor
                         );


        allow delete: if isGuildMember(guildId, request.auth.uid) &&
                         (
                           hasGuildPermission(guildId, request.auth.uid, 'MANAGE_EVENTS_DELETE') ||
                           request.auth.uid == resource.data.organizerId // Organizer can delete their own event
                         );
      }

      // Rules for 'groups' subcollection
      match /groups/{groupId} {
        allow read: if isGuildMember(guildId, request.auth.uid);
        allow list: if isGuildMember(guildId, request.auth.uid);

        allow create: if isGuildMember(guildId, request.auth.uid) &&
                         hasGuildPermission(guildId, request.auth.uid, 'MANAGE_GROUPS_CREATE') &&
                         request.resource.data.createdBy == request.auth.uid &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.createdAt == request.time;

        allow update: if isGuildMember(guildId, request.auth.uid) &&
                         hasGuildPermission(guildId, request.auth.uid, 'MANAGE_GROUPS_EDIT');

        allow delete: if isGuildMember(guildId, request.auth.uid) &&
                         hasGuildPermission(guildId, request.auth.uid, 'MANAGE_GROUPS_DELETE');
      }

      // Rules for 'notifications' subcollection
      match /notifications/{notificationId} {
        allow read: if isGuildMember(guildId, request.auth.uid); // All members can read notifications
        allow list: if isGuildMember(guildId, request.auth.uid);
        // Creation is typically server-side or by specific privileged actions (e.g., new mandatory event)
        // For simplicity, allow creation by any member if they set createdByUserId to themselves.
        // Specific notification types might have stricter creation logic in Cloud Functions.
        allow create: if request.auth.uid != null && isGuildMember(guildId, request.auth.uid) &&
                         request.resource.data.guildId == guildId &&
                         request.resource.data.timestamp == request.time &&
                         (!request.resource.data.containsKey('createdByUserId') || request.resource.data.createdByUserId == request.auth.uid);
        allow update, delete: if false; // Notifications are generally immutable or managed by system/owner
      }

      // Rules for 'dkpDecayLogs' subcollection (NEW)
      match /dkpDecayLogs/{decayLogId} {
        allow read: if isGuildMember(guildId, request.auth.uid) &&
                       (hasGuildPermission(guildId, request.auth.uid, 'MANAGE_GUILD_SETTINGS_GENERAL') || request.auth.uid == get(/databases/$(database)/documents/guilds/$(guildId)).data.ownerId ); // Owner or someone with DKP settings perm
        allow list: if isGuildMember(guildId, request.auth.uid) &&
                       (hasGuildPermission(guildId, request.auth.uid, 'MANAGE_GUILD_SETTINGS_GENERAL') || request.auth.uid == get(/databases/$(database)/documents/guilds/$(guildId)).data.ownerId );
        // Logs are created by system or specific admin action (on-demand decay)
        allow create: if request.auth.uid == get(/databases/$(database)/documents/guilds/$(guildId)).data.ownerId || // Owner triggering on-demand
                       (request.resource.data.triggeredByUserId == 'system'); // System triggered scheduled decay
        allow update, delete: if false; // Logs are immutable
      }
    }

    // Rules for 'users' collection
    match /users/{userId} {
      allow read: if request.auth.uid == userId || exists(/databases/$(database)/documents/guilds/{guildId}) where request.auth.uid in get(/databases/$(database)/documents/guilds/{guildId}).data.memberIds; // User can read their own profile, or if they are a member of any guild (for member lists)
      allow create: if request.auth.uid == userId && // User can create their own profile
                       request.resource.data.uid == userId &&
                       !exists(/databases/$(database)/documents/users/$(userId)); // Profile doesn't exist yet
      allow update: if request.auth.uid == userId && // User can update their own profile
                       // Allow updating displayName, photoURL, and lastNotificationsCheckedTimestamp
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['displayName', 'photoURL', 'lastNotificationsCheckedTimestamp']);
      allow delete: if false; // Users cannot delete their own profiles for now
    }
  }
}

    